from __future__ import annotations
import pybind11_stubgen.typing_ext
import typing
import wpilib._wpilib
import wpilib.interfaces._interfaces
import wpimath.units
import wpiutil._wpiutil
from . import led
from . import sensors
__all__ = ['BaseMotorController', 'BaseMotorControllerConfiguration', 'BaseMotorControllerUtil', 'BasePIDSetConfiguration', 'BaseTalon', 'BaseTalonConfigUtil', 'BaseTalonConfiguration', 'BaseTalonPIDSetConfigUtil', 'BaseTalonPIDSetConfiguration', 'BufferedTrajectoryPointStream', 'CANBusAddressable', 'CANifier', 'CANifierConfigUtils', 'CANifierConfiguration', 'CANifierControlFrame', 'CANifierFaults', 'CANifierStatusFrame', 'CANifierStickyFaults', 'CANifierVelocityMeasPeriod', 'ControlFrame', 'ControlFrameEnhanced', 'ControlMode', 'CustomParamConfigUtil', 'CustomParamConfiguration', 'DemandType', 'ErrorCode', 'Faults', 'FeedbackDevice', 'FilterConfigUtil', 'FilterConfiguration', 'FollowerType', 'IFollower', 'IGadgeteerUartClient', 'IInvertable', 'ILoopable', 'IMotorController', 'IMotorControllerEnhanced', 'IOutputSignal', 'IProcessable', 'InvertType', 'LimitSwitchNormal', 'LimitSwitchRoutines', 'LimitSwitchSource', 'MotionProfileStatus', 'MotorCommutation', 'MovingAverage', 'NeutralMode', 'Orchestra', 'ParamEnum', 'RemoteFeedbackDevice', 'RemoteLimitSwitchSource', 'RemoteSensorSource', 'SensorCollection', 'SensorTerm', 'SetValueMotionProfile', 'SlotConfigUtil', 'SlotConfiguration', 'StatorCurrentLimitConfiguration', 'StatusFrame', 'StatusFrameEnhanced', 'StatusFrameRoutines', 'StickyFaults', 'SupplyCurrentLimitConfiguration', 'TalonFX', 'TalonFXConfigUtil', 'TalonFXConfiguration', 'TalonFXControlMode', 'TalonFXFeedbackDevice', 'TalonFXInvertType', 'TalonFXPIDSetConfiguration', 'TalonFXSensorCollection', 'TalonFXSimCollection', 'TalonSRX', 'TalonSRXConfigUtil', 'TalonSRXConfiguration', 'TalonSRXControlMode', 'TalonSRXFeedbackDevice', 'TalonSRXPIDSetConfiguration', 'TalonSRXSimCollection', 'TrajectoryPoint', 'Unmanaged', 'VelocityMeasPeriod', 'VictorConfigUtil', 'VictorSPX', 'VictorSPXConfiguration', 'VictorSPXControlMode', 'VictorSPXPIDSetConfigUtil', 'VictorSPXPIDSetConfiguration', 'VictorSPXSimCollection', 'WPI_BaseMotorController', 'WPI_TalonFX', 'WPI_TalonSRX', 'WPI_VictorSPX', 'led', 'sensors']
class BaseMotorController(IMotorController):
    """
    Base motor controller features for all CTRE CAN motor controllers.
    """
    @staticmethod
    def destroyAllMotControllers() -> None:
        """
        Destructs all motor controller objects
        """
    def __init__(self, deviceNumber: int, model: str, canbus: str = '') -> None:
        """
        Constructor for motor controllers.
        
        :param arbId:  Device ID [0,62]
        :param model:  String model of device.
                       Examples: "Talon SRX", "Talon FX", "Victor SPX".
        :param canbus: Name of the CANbus; can be a SocketCAN interface (on Linux),
                       or a CANivore device name or serial number
        """
    def __repr__(self) -> str:
        ...
    def changeMotionControlFramePeriod(self, periodMs: int) -> ErrorCode:
        """
        Calling application can opt to speed up the handshaking between the robot
        API and the controller to increase the download rate of the controller's Motion
        Profile. Ideally the period should be no more than half the period of a
        trajectory point.
        
        :param periodMs: The transmit period in ms.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileHasUnderrun(self, timeoutMs: int = 0) -> ErrorCode:
        """
        Clear the "Has Underrun" flag. Typically this is called after application
        has confirmed an underrun had occured.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileTrajectories(self) -> ErrorCode:
        """
        Clear the buffered motion profile in both controller's RAM (bottom), and in the
        API (top).
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode:
        """
        Clears all sticky faults.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Last Error Code generated by a function.
        """
    def configAllowableClosedloopError(self, slotIdx: int, allowableCloseLoopError: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the allowable closed-loop error in the given parameter slot.
        
        :param slotIdx:                 Parameter slot for the constant.
        :param allowableCloseLoopError: Value of the allowable closed-loop error in sensor units (or sensor units per 100ms for velocity).
        :param timeoutMs:               Timeout value in ms. If nonzero, function will wait for
                                        config success and report an error if it times out.
                                        If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAuxPIDPolarity(self, invert: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the Polarity of the Auxiliary PID (PID1).
        
        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,
        
        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,
        
        :param invert:    If true, use inverted PID1 output polarity.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered
        
        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered
        
        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected
        
        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeakOutput(self, slotIdx: int, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the peak closed-loop output.  This peak output is slot-specific and
        is applied to the output of the associated PID loop.
        This setting is seperate from the generic Peak Output setting.
        
        :param slotIdx:    Parameter slot for the constant.
        :param percentOut: Peak Percent Output from 0 to 1.  This value is absolute and
                           *						the magnitude will apply in both forward and reverse directions.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeriod(self, slotIdx: int, loopTimeMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the loop time (in milliseconds) of the PID closed-loop calculations.
        Default value is 1 ms.
        
        :param slotIdx:    Parameter slot for the constant.
        :param loopTimeMs: Loop timing of the closed-loop calculations.  Minimum value of
                           *						1 ms, maximum of 64 ms.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the closed-loop ramp rate of throttle output.
        
        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                         value of '0' will disable the ramp.
        :param timeoutMs:                Timeout value in ms. If nonzero, function will wait for
                                         config success and report an error if it times out.
                                         If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: int = 50) -> ErrorCode:
        """
        Revert all configurations to factory default values.
        Use this before your individual config* calls to avoid having to config every single param.
        
        Alternatively you can use the configAllSettings routine.
        
        :param timeoutMs: Timeout value in ms. Function will generate error if config is
                          not successful within timeout.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFeedbackNotContinuous(self, feedbackNotContinuous: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Disables continuous tracking of the position for analog and pulse-width.
        If the signal goes from 4095 to 0 (pulse-width) a motor controller will continue to read 4096 by default.
        If overflow tracking is disabled, it will wrap to 0 (not continuous)
        
        If using pulse-width on CTRE Mag Encoder (within one rotation) or absolute analog sensor (within one rotation),
        setting feedbackNotContinuous to true is recommended, to prevent intermittent
        connections from causing sensor "jumps" of 4096 (or 1024 for analog) units.
        
        :param feedbackNotContinuous: True to disable the overflow tracking.
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.
        
        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures a limit switch for a local/remote source.
        
        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.
        
        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.
        
        :param type:              Limit switch source. User can choose
                                  between the feedback connector, remote Talon SRX, CANifier, or
                                  deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward soft limit enable.
        
        :param enable:    Forward Sensor Position Limit Enable.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitThreshold(self, forwardSensorLimit: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward soft limit threhold.
        
        :param forwardSensorLimit: Forward Sensor Position Limit (in raw sensor units).
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int:
        """
        Gets the value of a custom parameter.
        
        :param paramIndex: Index of custom parameter [0,1].
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.
        
        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float:
        """
        Gets a parameter.
        
        :param param:     Parameter enumeration.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Value of parameter.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, valueToSend: int, ordinal: int, timeoutMs: int) -> tuple[ErrorCode, int, int]:
        """
        Gets a parameter by passing an int by reference
        
        :param param:         Parameter enumeration
        :param valueToSend:   Value to send to parameter
        :param valueReceived: Reference to integer to receive
        :param subValue:      SubValue of parameter
        :param ordinal:       Ordinal of parameter
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configLimitSwitchDisableNeutralOnLOS(self, limitSwitchDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Disables limit switches triggering (if enabled) when the sensor is no longer detected.
        
        :param limitSwitchDisableNeutralOnLOS: disable triggering
        :param timeoutMs:                      Timeout value in ms. If nonzero, function will wait for
                                               config success and report an error if it times out.
                                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMaxIntegralAccumulator(self, slotIdx: int, iaccum: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the maximum integral accumulator in the given parameter slot.
        
        :param slotIdx:   Parameter slot for the constant.
        :param iaccum:    Value of the maximum integral accumulator (closed loop error
                          units X 1ms).
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionAcceleration(self, sensorUnitsPer100msPerSec: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the Motion Magic Acceleration. This is the target acceleration that
        the motion magic curve generator can use.
        
        :param sensorUnitsPer100msPerSec: Motion Magic Acceleration (in raw sensor units per 100 ms per
                                          second).
        :param timeoutMs:                 Timeout value in ms. If nonzero, function will wait for config
                                          success and report an error if it times out. If zero, no
                                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionCruiseVelocity(self, sensorUnitsPer100ms: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the Motion Magic Cruise Velocity. This is the peak target velocity
        that the motion magic curve generator can use.
        
        :param sensorUnitsPer100ms: Motion Magic Cruise Velocity (in raw sensor units per 100 ms).
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for config
                                    success and report an error if it times out. If zero, no
                                    blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryInterpolationEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        When trajectory points are processed in the buffer, the motor controller can
        linearly interpolate additional trajectory points between the buffered
        points.  The time delta between these interpolated points is 1 ms.
        
        By default this feature is enabled.
        
        :param enable:    Whether to enable the trajectory point interpolation feature.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryPeriod(self, baseTrajDurationMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        When trajectory points are processed in the motion profile executer, the MPE determines
        how long to apply the active trajectory point by summing baseTrajDurationMs with the
        timeDur of the trajectory point (see TrajectoryPoint).
        
        This allows general selection of the execution rate of the points with 1ms resolution,
        while allowing some degree of change from point to point.
        
        :param baseTrajDurationMs: The base duration time of every trajectory point.
                                   This is summed with the trajectory points unique timeDur.
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionSCurveStrength(self, curveStrength: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the Motion Magic S Curve Strength.
        Call this before using Motion Magic.
        Modifying this during a Motion Magic action should be avoided.
        
        :param curveStrength: 0 to use Trapezoidal Motion Profile. [1,8] for S-Curve (greater value yields greater smoothing).
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for config
                              success and report an error if it times out. If zero, no
                              blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNeutralDeadband(self, percentDeadband: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the output deadband percentage.
        
        :param percentDeadband: Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
                                Pass 0.04 for 4% (factory default).
        :param timeoutMs:       Timeout value in ms. If nonzero, function will wait for
                                config success and report an error if it times out.
                                If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward nominal output percentage.
        
        :param percentOut: Nominal (minimum) percent output. [0,+1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse nominal output percentage.
        
        :param percentOut: Nominal (minimum) percent output. [-1,0]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configOpenloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the open-loop ramp rate of throttle output.
        
        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                         value of '0' will disable the ramp.
        :param timeoutMs:                Timeout value in ms. If nonzero, function will wait for
                                         config success and report an error if it times out.
                                         If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward peak output percentage.
        
        :param percentOut: Desired peak output percentage. [0,1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse peak output percentage.
        
        :param percentOut: Desired peak output percentage.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_EdgesPerRot(self, pulseWidthPeriod_EdgesPerRot: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the edges per rotation of a pulse width sensor. (This should be set for
        tachometer use).
        
        :param pulseWidthPeriod_EdgesPerRot: edges per rotation
        :param timeoutMs:                    Timeout value in ms. If nonzero, function will wait for
                                             config success and report an error if it times out.
                                             If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_FilterWindowSz(self, pulseWidthPeriod_FilterWindowSz: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the number of samples to use in smoothing a pulse width sensor with a rolling
        average. Default is 1 (no smoothing).
        
        :param pulseWidthPeriod_FilterWindowSz: samples for rolling avg
        :param timeoutMs:                       Timeout value in ms. If nonzero, function will wait for
                                                config success and report an error if it times out.
                                                If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, deviceID: int, remoteSensorSource: RemoteSensorSource, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.
        
        :param deviceID:           The device ID of the remote sensor device.
        :param remoteSensorSource: The remote sensor device and signal type to bind.
        :param remoteOrdinal:      0 for configuring Remote Sensor 0,
                                   1 for configuring Remote Sensor 1
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, canCoderRef: sensors.CANCoder, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.
        
        :param canCoderRef:   CANCoder device reference to use.
        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                              1 for configuring Remote Sensor 1
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, talonRef: BaseTalon, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.
        
        :param talonRef:      Talon device reference to use.
        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                              1 for configuring Remote Sensor 1
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configRemoteSensorClosedLoopDisableNeutralOnLOS(self, remoteSensorClosedLoopDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Disables going to neutral (brake/coast) when a remote sensor is no longer detected.
        
        :param remoteSensorClosedLoopDisableNeutralOnLOS: disable going to neutral
        :param timeoutMs:                                 Timeout value in ms. If nonzero, function will wait for
                                                          config success and report an error if it times out.
                                                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.
        
        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures a limit switch for a local/remote source.
        
        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.
        
        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.
        
        :param type:              Limit switch source. User can choose
                                  between the feedback connector, remote Talon SRX, CANifier, or
                                  deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse soft limit enable.
        
        :param enable:    Reverse Sensor Position Limit Enable.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitThreshold(self, reverseSensorLimit: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse soft limit threshold.
        
        :param reverseSensorLimit: Reverse Sensor Position Limit (in raw sensor units).
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackCoefficient(self, coefficient: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        The Feedback Coefficient is a scalar applied to the value of the
        feedback sensor.  Useful when you need to scale your sensor values
        within the closed-loop calculations.  Default value is 1.
        
        Selected Feedback Sensor register in firmware is the decoded sensor value
        multiplied by the Feedback Coefficient.
        
        :param coefficient: Feedback Coefficient value.  Maximum value of 1.
                            *						Resolution is 1/(2^16).  Cannot be 0.
        :param pidIdx:      0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.
        
        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the feedback device for the motor controller.
        
        :param feedbackDevice: Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: FeedbackDevice, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.
        
        :param sensorTerm:     Which sensor term to bind to a feedback source.
        :param feedbackDevice: The sensor signal to attach to sensorTerm.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: RemoteFeedbackDevice, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.
        
        :param sensorTerm:     Which sensor term to bind to a feedback source.
        :param feedbackDevice: The sensor signal to attach to sensorTerm.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the value of a custom parameter. This is for arbitrary use.
        
        Sometimes it is necessary to save calibration/limit/target information in
        the device. Particularly if the device is part of a subsystem that can be
        replaced.
        
        :param newValue:   Value for custom parameter.
        :param paramIndex: Index of custom parameter [0,1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets a parameter. Generally this is not used. This can be utilized in -
        Using new features without updating API installation. - Errata
        workarounds to circumvent API implementation. - Allows for rapid testing
        / unit testing of firmware.
        
        :param param:     Parameter enumeration.
        :param value:     Value of parameter.
        :param subValue:  Subvalue for parameter. Maximum value of 255.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSoftLimitDisableNeutralOnLOS(self, softLimitDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Disables soft limits triggering (if enabled) when the sensor is no longer detected.
        
        :param softLimitDisableNeutralOnLOS: disable triggering
        :param timeoutMs:                    Timeout value in ms. If nonzero, function will wait for
                                             config success and report an error if it times out.
                                             If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: sensors.SensorVelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period over which velocity measurements are taken.
        
        :param period:    Desired period for the velocity measurement. @see
                          #SensorVelocityMeasPeriod
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.
        
        :param windowSize: Number of samples in the rolling average of velocity
                           measurement. Valid values are 1,2,4,8,16,32. If another value
                           is specified, it will truncate to nearest support value.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageCompSaturation(self, voltage: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the Voltage Compensation saturation voltage.
        
        :param voltage:   This is the max voltage to apply to the hbridge when voltage
                          compensation is enabled.  For example, if 10 (volts) is specified
                          and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
                          then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageMeasurementFilter(self, filterWindowSamples: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the voltage measurement filter.
        
        :param filterWindowSamples: Number of samples in the rolling average of voltage
                                    measurement.
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_IntegralZone(self, slotIdx: int, izone: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the Integral Zone constant in the given parameter slot. If the
        (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.
        
        :param slotIdx:   Parameter slot for the constant.
        :param izone:     Value of the Integral Zone constant (closed loop error units X
                          1ms).
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kD(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the 'D' constant in the given parameter slot.
        
        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)
        
        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the D constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kF(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the 'F' constant in the given parameter slot.
        
        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).
        
        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the F constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kI(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the 'I' constant in the given parameter slot.
        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].
        
        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the I constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kP(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the 'P' constant in the given parameter slot.
        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)
        
        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the P constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configureSlot(self, slot: SlotConfiguration, slotIdx: int, timeoutMs: int) -> ErrorCode:
        """
        Configures all slot persistant settings
        
        :param slot:      Object with all of the slot persistant settings
        :param slotIdx:   Index of slot to configure
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def enableVoltageCompensation(self, enable: bool) -> None:
        """
        Enables voltage compensation. If enabled, voltage compensation works in
        all control modes.
        
        Be sure to configure the saturation voltage before enabling this.
        
        :param enable: Enable state of voltage compensation.
        """
    @typing.overload
    def follow(self, masterToFollow: IMotorController, followerType: FollowerType) -> None:
        """
        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX,
        Talon SRX, and Talon FX.
        
        :param masterToFollow: *						Motor Controller object to follow.
        :param followerType:   *						Type of following control.  Use AuxOutput1 to follow the master
                               *						device's auxiliary output 1.
                               *						Use PercentOutput for standard follower mode.
        """
    @typing.overload
    def follow(self, masterToFollow: IMotorController) -> None:
        """
        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX,
        Talon SRX, and Talon FX.
        """
    def getActiveTrajectoryArbFeedFwd(self, pidIdx: int = 0) -> float:
        """
        Gets the active trajectory arbitrary feedforward using
        MotionMagic/MotionProfile control modes.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: The Active Trajectory ArbFeedFwd in units of percent output
                  (where 0.01 is 1%).
        """
    def getActiveTrajectoryPosition(self, pidIdx: int = 0) -> float:
        """
        Gets the active trajectory target position using
        MotionMagic/MotionProfile control modes.
        
        :returns: The Active Trajectory Position in sensor units.
        """
    def getActiveTrajectoryVelocity(self, pidIdx: int = 0) -> float:
        """
        Gets the active trajectory target velocity using
        MotionMagic/MotionProfile control modes.
        
        :returns: The Active Trajectory Velocity in sensor units per 100ms.
        """
    def getBaseID(self) -> int:
        ...
    def getBusVoltage(self) -> float:
        """
        Gets the bus voltage seen by the device.
        
        :returns: The bus voltage value (in volts).
        """
    def getClosedLoopError(self, pidIdx: int = 0) -> float:
        """
        Gets the closed-loop error. The units depend on which control mode is in
        use.
        
        If closed-loop is seeking a target sensor position, closed-loop error is the difference between target
        and current sensor value (in sensor units.  Example 4096 units per rotation for CTRE Mag Encoder).
        
        If closed-loop is seeking a target sensor velocity, closed-loop error is the difference between target
        and current sensor value (in sensor units per 100ms).
        
        If using motion profiling or Motion Magic, closed loop error is calculated against the current target,
        and not the "final" target at the end of the profile/movement.
        
        See Phoenix-Documentation information on units.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: Closed-loop error value.
        """
    def getClosedLoopTarget(self, pidIdx: int = 0) -> float:
        """
        Gets the current target of a given closed loop.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: The closed loop target.
        """
    def getControlMode(self) -> ControlMode:
        """
        :returns: control mode motor controller is in
        """
    def getDeviceID(self) -> int:
        """
        Returns the Device ID
        
        :returns: Device number.
        """
    def getErrorDerivative(self, pidIdx: int = 0) -> float:
        """
        Gets the derivative of the closed-loop error.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: The error derivative value.
        """
    def getFaults(self, toFill: Faults) -> ErrorCode:
        """
        Polls the various fault flags.
        
        :param toFill: Caller's object to fill with latest fault flags.
        
        :returns: Last Error Code generated by a function.
        """
    def getFilterConfigs(self, Filter: FilterConfiguration, ordinal: int = 0, timeoutMs: int = 50) -> None:
        """
        Gets all filter persistant settings.
        
        :param Filter:    Object with all of the filter persistant settings
        :param ordinal:   0 for remote sensor 0 and 1 for remote sensor 1.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getFirmwareVersion(self) -> int:
        """
        Gets the firmware version of the device.
        
        :returns: Firmware version of device. For example: version 1-dot-2 is
                  0x0102.
        """
    def getIntegralAccumulator(self, pidIdx: int = 0) -> float:
        """
        Gets the iaccum value.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: Integral accumulator value (Closed-loop error X 1ms).
        """
    def getInverted(self) -> bool:
        """
        :returns: invert setting of motor output.
        """
    def getLastError(self) -> ErrorCode:
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.
        
        :returns: Last Error Code generated by a function.
        """
    def getMotionProfileStatus(self, statusToFill: MotionProfileStatus) -> ErrorCode:
        """
        Retrieve all status information.
        For best performance, Caller can snapshot all status information regarding the
        motion profile executer.
        
        The members are filled, as follows...
        
        *	topBufferRem:	The available empty slots in the trajectory buffer.
        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the
        low-level buffer, allowing the motor controller to act on them.
        
        *	topBufferRem: The number of points in the top trajectory buffer.
        
        *	btmBufferCnt: The number of points in the low level controller buffer.
        
        *	hasUnderrun: 	Set if isUnderrun ever gets set.
        Can be manually cleared by ClearMotionProfileHasUnderrun() or automatically cleared by StartMotionProfile().
        
        *	isUnderrun:		This is set if controller needs to shift a point from its buffer into
        *					the active trajectory point however
        *					the buffer is empty.
        *					This gets cleared automatically when is resolved.
        
        *	activePointValid:	True if the active trajectory point is not empty, false otherwise. The members in activePoint are only valid if this signal is set.
        
        *	isLast:	is set/cleared based on the MP executer's current
        trajectory point's IsLast value.  This assumes
        IsLast was set when PushMotionProfileTrajectory
        was used to insert the currently processed trajectory
        point.
        
        *	profileSlotSelect: The currently processed trajectory point's
        selected slot.  This can differ in the currently selected slot used
        for Position and Velocity servo modes
        
        *	outputEnable:		The current output mode of the motion profile
        *						executer (disabled, enabled, or hold).  When changing the set()
        *						value in MP mode, it's important to check this signal to
        *						confirm the change takes effect before interacting with the top buffer.
        
        :param statusToFill: Caller supplied object to fill.
        """
    def getMotionProfileTopLevelBufferCount(self) -> int:
        """
        Retrieve just the buffer count for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll the progress of trajectory points being
        emptied into controller's RAM. Otherwise just use GetMotionProfileStatus.
        
        :returns: number of trajectory points in the top buffer.
        """
    def getMotorOutputPercent(self) -> float:
        """
        Gets the output percentage of the motor controller.
        
        :returns: Output of the motor controller (in percent).
        """
    def getMotorOutputVoltage(self) -> float:
        """
        :returns: applied voltage to motor  in volts.
        """
    def getSelectedSensorPosition(self, pidIdx: int = 0) -> float:
        """
        Get the selected sensor position (in raw sensor units).
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop. See
                       Phoenix-Documentation for how to interpret.
        
        :returns: Position of selected sensor (in raw sensor units).
        """
    def getSelectedSensorVelocity(self, pidIdx: int = 0) -> float:
        """
        Get the selected sensor velocity.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: selected sensor (in raw sensor units) per 100ms.
                  See Phoenix-Documentation for how to interpret.
        """
    def getSlotConfigs(self, slot: SlotConfiguration, slotIdx: int = 0, timeoutMs: int = 50) -> None:
        """
        Gets all slot persistant settings.
        
        :param slot:      Object with all of the slot persistant settings
        :param slotIdx:   Parameter slot for the constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: StickyFaults) -> ErrorCode:
        """
        Polls the various sticky fault flags.
        
        :param toFill: Caller's object to fill with latest sticky fault flags.
        
        :returns: Last Error Code generated by a function.
        """
    def getTemperature(self) -> float:
        """
        Gets the temperature of the motor controller.
        
        :returns: Temperature of the motor controller (in 'C)
        """
    def hasResetOccurred(self) -> bool:
        """
        Returns true if the device has reset since last call.
        
        :returns: Has a Device Reset Occurred?
        """
    def isMotionProfileFinished(self) -> bool:
        """
        Determine if running MP is complete.
        This requires using the StartMotionProfile routine to start the MP.
        That is because managing the trajectory points is now done in a background thread (if StartMotionProfile is called).
        
        If calling application uses the legacy API  (more-complex buffering API) from previous years, than this API will
        not return true.
        
        :returns: true if MP was started using StartMotionProfile, and it has completed execution (MPE is now in "hold").
        """
    def isMotionProfileTopLevelBufferFull(self) -> bool:
        """
        Retrieve just the buffer full for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll. Otherwise just use
        GetMotionProfileStatus.
        
        :returns: number of trajectory points in the top buffer.
        """
    def isVoltageCompensationEnabled(self) -> bool:
        """
        Returns the enable state of Voltage Compensation that the caller has set.
        
        :returns: TRUE if voltage compensation is enabled.
        """
    def neutralOutput(self) -> None:
        """
        Neutral the motor output by setting control mode to disabled.
        """
    def overrideLimitSwitchesEnable(self, enable: bool) -> None:
        """
        Sets the enable state for limit switches.
        
        :param enable: Enable state for limit switches.
        """
    def overrideSoftLimitsEnable(self, enable: bool) -> None:
        """
        Can be used to override-disable the soft limits.
        This function can be used to quickly disable soft limits without
        having to modify the persistent configuration.
        
        :param enable: Enable state for soft limit switches.
        """
    def processMotionProfileBuffer(self) -> None:
        """
        This must be called periodically to funnel the trajectory points from the
        API's top level buffer to the controller's bottom level buffer. Recommendation
        is to call this twice as fast as the execution rate of the motion
        profile. So if MP is running with 20ms trajectory points, try calling
        this routine every 10ms. All motion profile functions are thread-safe
        through the use of a mutex, so there is no harm in having the caller
        utilize threading.
        """
    def pushMotionProfileTrajectory(self, trajPt: TrajectoryPoint) -> ErrorCode:
        """
        Push another trajectory point into the top level buffer (which is emptied
        into the motor controller's bottom buffer as room allows).
        
        targPos:  servo position in sensor units.
        *		targVel:  velocity to feed-forward in sensor units
        per 100ms.
        profileSlotSelect0  Which slot to get PIDF gains. PID is used for position servo. F is used
        *						   as the Kv constant for velocity feed-forward. Typically this is hardcoded
        *						   to the a particular slot, but you are free gain schedule if need be.
        *						   Choose from [0,3]
        *		profileSlotSelect1 Which slot to get PIDF gains for auxiliary PId.
        *						   This only has impact during MotionProfileArc Control mode.
        *						   Choose from [0,1].
        isLastPoint  set to nonzero to signal motor controller to keep processing this
        trajectory point, instead of jumping to the next one
        when timeDurMs expires.  Otherwise MP executer will
        eventually see an empty buffer after the last point
        expires, causing it to assert the IsUnderRun flag.
        However this may be desired if calling application
        never wants to terminate the MP.
        *		zeroPos  set to nonzero to signal motor controller to "zero" the selected
        position sensor before executing this trajectory point.
        Typically the first point should have this set only thus
        allowing the remainder of the MP positions to be relative to
        zero.
        *		timeDur Duration to apply this trajectory pt.
        This time unit is ADDED to the exising base time set by
        configMotionProfileTrajectoryPeriod().
        
        :param trajPt: to push into buffer.
                       The members should be filled in with these values...
        
        :returns: CTR_OKAY if trajectory point push ok. ErrorCode if buffer is
                  full due to kMotionProfileTopBufferCapacity.
        """
    def selectProfileSlot(self, slotIdx: int, pidIdx: int) -> ErrorCode:
        """
        Selects which profile slot to use for closed-loop control.
        
        :param slotIdx: Profile slot to select.
        :param pidIdx:  0 for Primary closed-loop. 1 for auxiliary closed-loop.
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None:
        """
        Sets the appropriate output on the talon, depending on the mode.
        
        *	Standard Driving Example:
        *	_talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *	_talonRght.set(ControlMode.PercentOutput, rghtJoy);
        
        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Current mode, output value is in amperes.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the talon to
                      duplicate.
        :param value: The setpoint value, as described above.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        """
        Arcade Drive Example:
        *		_talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);
        
        *	Drive Straight Example:
        *	Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);
        
        *	Drive Straight to a Distance Example:
        *	Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        
        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                            PID is always executed as standard Position PID control.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *	 demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.
                            AuxPID: Target position in Sensor Units
                            ArbitraryFeedForward: Percent Output between -1.0 and 1.0
        """
    def setControlFramePeriod(self, frame: ControlFrame, periodMs: int) -> ErrorCode:
        """
        Sets the period of the given control frame.
        
        :param frame:    Frame whose period is to be changed.
        :param periodMs: Period in ms for the given frame.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setIntegralAccumulator(self, iaccum: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the integral accumulator. Typically this is used to clear/zero the
        integral accumulator, however some use cases may require seeding the
        accumulator for a faster response.
        
        :param iaccum:    Value to set for the integral accumulator (closed loop error
                          units X 1ms).
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setInverted(self, invert: bool) -> None:
        """
        Inverts the hbridge output of the motor controller.
        
        This does not impact sensor phase and should not be used to correct sensor polarity.
        
        This will invert the hbridge output but NOT the LEDs.
        This ensures....
        - Green LEDs always represents positive request from robot-controller/closed-looping mode.
        - Green LEDs correlates to forward limit switch.
        - Green LEDs correlates to forward soft limit.
        
        :param invert: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None:
        """
        Inverts the hbridge output of the motor controller in relation to the master if present
        
        This does not impact sensor phase and should not be used to correct sensor polarity.
        
        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion
        
        :param invertType: Invert state to set.
        """
    def setNeutralMode(self, neutralMode: NeutralMode) -> None:
        """
        Sets the mode of operation during neutral throttle output.
        
        :param neutralMode: The desired mode of operation when the Controller output
                            throttle is neutral (ie brake/coast)
        """
    def setSelectedSensorPosition(self, sensorPos: float, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode:
        """
        Sets the sensor position to the given value.
        
        :param sensorPos: Position to set for the selected sensor (in raw sensor units).
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setSensorPhase(self, PhaseSensor: bool) -> None:
        """
        Sets the phase of the sensor. Use when controller forward/reverse output
        doesn't correlate to appropriate forward/reverse reading of sensor.
        Pick a value so that positive PercentOutput yields a positive change in sensor.
        After setting this, user can freely call SetInverted() with any value.
        
        :param PhaseSensor: Indicates whether to invert the phase of the sensor.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period of the given status frame.
        
        User ensure CAN Bus utilization is not high.
        
        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.
        
        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period of the given status frame.
        
        User ensure CAN Bus utilization is not high.
        
        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.
        
        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def startMotionProfile(self, stream: BufferedTrajectoryPointStream, minBufferedPts: int, motionProfControlMode: ControlMode) -> ErrorCode:
        """
        Simple one-shot firing of a complete MP.
        Starting in 2019, MPs can be fired by building a Buffered Trajectory Point Stream, and calling this routine.
        
        Once called, the motor controller software will automatically ...
        [1] Clear the firmware buffer of trajectory points.
        [2] Clear the underrun flags
        [3] Reset an index within the Buffered Trajectory Point Stream (so that the same profile can be run again and again).
        [4] Start a background thread to manage MP streaming (if not already running).
        [5a] If current control mode already matches motionProfControlMode, set MPE Output to "Hold".
        [5b] If current control mode does not matches motionProfControlMode, apply motionProfControlMode and set MPE Output to "Disable".
        [6] Stream the trajectory points into the device's firmware buffer.
        [7] Once motor controller has at least minBufferedPts worth in the firmware buffer, MP will automatically start (MPE Output set to "Enable").
        [8] Wait until MP finishes, then transitions the Motion Profile Executor's output to "Hold".
        [9] IsMotionProfileFinished() will now return true.
        
        Calling application can use IsMotionProfileFinished() to determine when internal state machine reaches [7].
        Calling application can cancel MP by calling set().  Otherwise do not call set() until MP has completed.
        
        The legacy API from previous years requires the calling application to pass points via the ProcessMotionProfileBuffer and PushMotionProfileTrajectory.
        This is no longer required if using this StartMotionProfile/IsMotionProfileFinished API.
        
        :param stream:                A buffer that will be used to stream the trajectory points.  Caller can fill this container with the entire trajectory point, regardless of size.
        :param minBufferedPts:        Minimum number of firmware buffered points before starting MP.
                                      *							Do not exceed device's firmware buffer capacity or MP will never fire (120 for Motion Profile, or 60 for Motion Profile Arc).
                                      *							Recommendation value for this would be five to ten samples depending on timeDur of the trajectory point.
        :param motionProfControlMode: Pass MotionProfile or MotionProfileArc.
        
        :returns: nonzero error code if operation fails.
        """
    def valueUpdated(self) -> None:
        """
        When master makes a device, this routine is called to signal the update.
        """
class BaseMotorControllerConfiguration(CustomParamConfiguration):
    """
    Configurables available to base motor controllers
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to configs
        
        :returns: String representation of configs
        """
    @property
    def auxPIDPolarity(self) -> bool:
        """
        PID polarity inversion
        
        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,
        
        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,
        """
    @auxPIDPolarity.setter
    def auxPIDPolarity(self, arg0: bool) -> None:
        ...
    @property
    def clearPositionOnLimitF(self) -> bool:
        """
        Clear the position on forward limit
        """
    @clearPositionOnLimitF.setter
    def clearPositionOnLimitF(self, arg0: bool) -> None:
        ...
    @property
    def clearPositionOnLimitR(self) -> bool:
        """
        Clear the position on reverse limit
        """
    @clearPositionOnLimitR.setter
    def clearPositionOnLimitR(self, arg0: bool) -> None:
        ...
    @property
    def clearPositionOnQuadIdx(self) -> bool:
        """
        Clear the position on index
        """
    @clearPositionOnQuadIdx.setter
    def clearPositionOnQuadIdx(self, arg0: bool) -> None:
        ...
    @property
    def closedloopRamp(self) -> float:
        """
        Seconds to go from 0 to full in closed loop
        """
    @closedloopRamp.setter
    def closedloopRamp(self, arg0: float) -> None:
        ...
    @property
    def feedbackNotContinuous(self) -> bool:
        """
        Determine whether feedback sensor is continuous or not
        """
    @feedbackNotContinuous.setter
    def feedbackNotContinuous(self, arg0: bool) -> None:
        ...
    @property
    def forwardSoftLimitEnable(self) -> bool:
        """
        Enable forward soft limit
        """
    @forwardSoftLimitEnable.setter
    def forwardSoftLimitEnable(self, arg0: bool) -> None:
        ...
    @property
    def forwardSoftLimitThreshold(self) -> float:
        """
        Threshold for soft limits in forward direction (in raw sensor units)
        """
    @forwardSoftLimitThreshold.setter
    def forwardSoftLimitThreshold(self, arg0: float) -> None:
        ...
    @property
    def limitSwitchDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote limit switch is lost on CAN bus
        """
    @limitSwitchDisableNeutralOnLOS.setter
    def limitSwitchDisableNeutralOnLOS(self, arg0: bool) -> None:
        ...
    @property
    def motionAcceleration(self) -> float:
        """
        Motion Magic acceleration in (raw sensor units per 100 ms) per second.
        """
    @motionAcceleration.setter
    def motionAcceleration(self, arg0: float) -> None:
        ...
    @property
    def motionCruiseVelocity(self) -> float:
        """
        Motion Magic cruise velocity in raw sensor units per 100 ms.
        """
    @motionCruiseVelocity.setter
    def motionCruiseVelocity(self, arg0: float) -> None:
        ...
    @property
    def motionCurveStrength(self) -> int:
        """
        Zero to use trapezoidal motion during motion magic.  [1,8] for S-Curve, higher value for greater smoothing.
        """
    @motionCurveStrength.setter
    def motionCurveStrength(self, arg0: int) -> None:
        ...
    @property
    def motionProfileTrajectoryPeriod(self) -> int:
        """
        Motion profile base trajectory period in milliseconds.
        
        The period specified in a trajectory point will be
        added on to this value
        """
    @motionProfileTrajectoryPeriod.setter
    def motionProfileTrajectoryPeriod(self, arg0: int) -> None:
        ...
    @property
    def neutralDeadband(self) -> float:
        """
        Neutral deadband [0.001, 0.25]
        """
    @neutralDeadband.setter
    def neutralDeadband(self, arg0: float) -> None:
        ...
    @property
    def nominalOutputForward(self) -> float:
        """
        Nominal/Minimum output in forward direction [0,1]
        """
    @nominalOutputForward.setter
    def nominalOutputForward(self, arg0: float) -> None:
        ...
    @property
    def nominalOutputReverse(self) -> float:
        """
        Nominal/Minimum output in reverse direction [-1,0]
        """
    @nominalOutputReverse.setter
    def nominalOutputReverse(self, arg0: float) -> None:
        ...
    @property
    def openloopRamp(self) -> float:
        """
        Seconds to go from 0 to full in open loop
        """
    @openloopRamp.setter
    def openloopRamp(self, arg0: float) -> None:
        ...
    @property
    def peakOutputForward(self) -> float:
        """
        Peak output in forward direction [0,1]
        """
    @peakOutputForward.setter
    def peakOutputForward(self, arg0: float) -> None:
        ...
    @property
    def peakOutputReverse(self) -> float:
        """
        Peak output in reverse direction [-1,0]
        """
    @peakOutputReverse.setter
    def peakOutputReverse(self, arg0: float) -> None:
        ...
    @property
    def pulseWidthPeriod_EdgesPerRot(self) -> int:
        """
        Number of edges per rotation for a tachometer sensor
        """
    @pulseWidthPeriod_EdgesPerRot.setter
    def pulseWidthPeriod_EdgesPerRot(self, arg0: int) -> None:
        ...
    @property
    def pulseWidthPeriod_FilterWindowSz(self) -> int:
        """
        Desired window size for a tachometer sensor
        """
    @pulseWidthPeriod_FilterWindowSz.setter
    def pulseWidthPeriod_FilterWindowSz(self, arg0: int) -> None:
        ...
    @property
    def remoteFilter0(self) -> FilterConfiguration:
        """
        Configuration for RemoteFilter 0
        """
    @remoteFilter0.setter
    def remoteFilter0(self, arg0: FilterConfiguration) -> None:
        ...
    @property
    def remoteFilter1(self) -> FilterConfiguration:
        """
        Configuration for RemoteFilter 1
        """
    @remoteFilter1.setter
    def remoteFilter1(self, arg0: FilterConfiguration) -> None:
        ...
    @property
    def remoteSensorClosedLoopDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote sensor is lost on CAN bus
        """
    @remoteSensorClosedLoopDisableNeutralOnLOS.setter
    def remoteSensorClosedLoopDisableNeutralOnLOS(self, arg0: bool) -> None:
        ...
    @property
    def reverseSoftLimitEnable(self) -> bool:
        """
        Enable reverse soft limit
        """
    @reverseSoftLimitEnable.setter
    def reverseSoftLimitEnable(self, arg0: bool) -> None:
        ...
    @property
    def reverseSoftLimitThreshold(self) -> float:
        """
        Threshold for soft limits in reverse direction (in raw sensor units)
        """
    @reverseSoftLimitThreshold.setter
    def reverseSoftLimitThreshold(self, arg0: float) -> None:
        ...
    @property
    def slot0(self) -> SlotConfiguration:
        """
        Configuration for slot 0
        """
    @slot0.setter
    def slot0(self, arg0: SlotConfiguration) -> None:
        ...
    @property
    def slot1(self) -> SlotConfiguration:
        """
        Configuration for slot 1
        """
    @slot1.setter
    def slot1(self, arg0: SlotConfiguration) -> None:
        ...
    @property
    def slot2(self) -> SlotConfiguration:
        """
        Configuration for slot 2
        """
    @slot2.setter
    def slot2(self, arg0: SlotConfiguration) -> None:
        ...
    @property
    def slot3(self) -> SlotConfiguration:
        """
        Configuration for slot 3
        """
    @slot3.setter
    def slot3(self, arg0: SlotConfiguration) -> None:
        ...
    @property
    def softLimitDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote soft limit is lost on CAN bus
        """
    @softLimitDisableNeutralOnLOS.setter
    def softLimitDisableNeutralOnLOS(self, arg0: bool) -> None:
        ...
    @property
    def trajectoryInterpolationEnable(self) -> bool:
        """
        Enable motion profile trajectory point interpolation (defaults to true).
        """
    @trajectoryInterpolationEnable.setter
    def trajectoryInterpolationEnable(self, arg0: bool) -> None:
        ...
    @property
    def velocityMeasurementPeriod(self) -> sensors.SensorVelocityMeasPeriod:
        """
        Desired period for velocity measurement
        """
    @velocityMeasurementPeriod.setter
    def velocityMeasurementPeriod(self, arg0: sensors.SensorVelocityMeasPeriod) -> None:
        ...
    @property
    def velocityMeasurementWindow(self) -> int:
        """
        Desired window for velocity measurement
        """
    @velocityMeasurementWindow.setter
    def velocityMeasurementWindow(self, arg0: int) -> None:
        ...
    @property
    def voltageCompSaturation(self) -> float:
        """
        This is the max voltage to apply to the hbridge when voltage
        compensation is enabled.  For example, if 10 (volts) is specified
        and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
        then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
        """
    @voltageCompSaturation.setter
    def voltageCompSaturation(self, arg0: float) -> None:
        ...
    @property
    def voltageMeasurementFilter(self) -> int:
        """
        Number of samples in rolling average for voltage
        """
    @voltageMeasurementFilter.setter
    def voltageMeasurementFilter(self, arg0: int) -> None:
        ...
class BaseMotorControllerUtil(CustomParamConfigUtil):
    """
    Util class to help with Base Motor Controller configs
    """
    @staticmethod
    def auxPIDPolarityDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def clearPositionOnLimitFDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def clearPositionOnLimitRDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def clearPositionOnQuadIdxDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def closedloopRampDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def feedbackNotContinuousDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def forwardSoftLimitEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def forwardSoftLimitThresholdDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def limitSwitchDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def motionAccelerationDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def motionCruiseVelocityDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def motionProfileTrajectoryPeriodDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def motionSCurveStrength(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def neutralDeadbandDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def nominalOutputForwardDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def nominalOutputReverseDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def openloopRampDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def peakOutputForwardDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def peakOutputReverseDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def pulseWidthPeriod_EdgesPerRotDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def pulseWidthPeriod_FilterWindowSzDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def remoteSensorClosedLoopDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def reverseSoftLimitEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def reverseSoftLimitThresholdDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def softLimitDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def trajectoryInterpolationEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def velocityMeasurementPeriodDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def velocityMeasurementWindowDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def voltageCompSaturationDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    @staticmethod
    def voltageMeasurementFilterDifferent(settings: BaseMotorControllerConfiguration) -> bool:
        ...
    def __init__(self) -> None:
        ...
class BasePIDSetConfiguration:
    """
    Base set of configurables related to PID
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to configs
        
        :returns: String representation of configs
        """
    @property
    def selectedFeedbackCoefficient(self) -> float:
        """
        Feedback coefficient of selected sensor
        """
    @selectedFeedbackCoefficient.setter
    def selectedFeedbackCoefficient(self, arg0: float) -> None:
        ...
class BaseTalon(BaseMotorController, IMotorControllerEnhanced):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int, model: str, canbus: str = '') -> None:
        """
        Constructor for a Talon
        
        :param deviceNumber: CAN Device ID of BaseTalon
        :param canbus:       Name of the CANbus; can be a SocketCAN interface (on Linux),
                             or a CANivore device name or serial number
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, limitSwitchSource: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures a limit switch for a local/remote source.
        
        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.
        
        If the sensor is remote, a device ID of zero is assumed.
        If that's not desired, use the four parameter version of this function.
        
        :param limitSwitchSource: Limit switch source.
                                  User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This setting
                                  matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for
                                  config success and report an error if it times out.
                                  If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, limitSwitchSource: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures a limit switch for a local/remote source.
        
        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.
        
        If the sensor is remote, a device ID of zero is assumed.
        If that's not desired, use the four parameter version of this function.
        
        :param limitSwitchSource: Limit switch source.
                                  User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This setting
                                  matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for
                                  config success and report an error if it times out.
                                  If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, limitSwitchSource: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures a limit switch for a local/remote source.
        
        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.
        
        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.
        
        :param limitSwitchSource: Limit switch source. @see #LimitSwitchSource User can choose
                                  between the feedback connector, remote Talon SRX, CANifier, or
                                  deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, limitSwitchSource: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures a limit switch for a local/remote source.
        
        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.
        
        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.
        
        :param limitSwitchSource: Limit switch source. @see #LimitSwitchSource User can choose
                                  between the feedback connector, remote Talon SRX, CANifier, or
                                  deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.
        
        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.
        
        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode:
        ...
    def configVelocityMeasurementPeriod(self, period: sensors.SensorVelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the period of each velocity sample.
        Every 1ms a position value is sampled, and the delta between that sample
        and the position sampled kPeriod ms ago is inserted into a filter.
        kPeriod is configured with this function.
        
        :param period:    Desired period for the velocity measurement. @see
                          #SensorVelocityMeasPeriod
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.
        
        :param windowSize: Number of samples in the rolling average of velocity
                           measurement. Valid values are 1,2,4,8,16,32. If another
                           value is specified, it will truncate to nearest support value.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getOutputCurrent(self) -> float:
        """
        Gets the output current of the motor controller.
        In the case of TalonSRX class, this routine returns supply current for legacy reasons.  In order to get the "true" output current, call GetStatorCurrent().
        In the case of TalonFX class, this routine returns the true output stator current.
        
        [[deprecated("Use GetStatorCurrent/GetSupplyCurrent instead.")]]
        
        :returns: The output current (in amps).
        """
    def getStatorCurrent(self) -> float:
        """
        Gets the stator/output current of the motor controller.
        
        :returns: The stator/output current (in amps).
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    def getSupplyCurrent(self) -> float:
        """
        Gets the supply/input current of the motor controller.
        
        :returns: The supply/input current (in amps).
        """
    def isFwdLimitSwitchClosed(self) -> int:
        ...
    def isRevLimitSwitchClosed(self) -> int:
        ...
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period of the given status frame.
        
        User ensure CAN Bus utilization is not high.
        
        This setting is not persistent and is lost when device is reset.
        If this is a concern, calling application can use HasResetOccurred()
        to determine if the status frame needs to be reconfigured.
        
        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period of the given status frame.
        
        User ensure CAN Bus utilization is not high.
        
        This setting is not persistent and is lost when device is reset.
        If this is a concern, calling application can use HasResetOccurred()
        to determine if the status frame needs to be reconfigured.
        
        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
class BaseTalonConfigUtil:
    """
    Util class to help with talon configs
    """
    @staticmethod
    def diff0TermDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def diff1TermDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def forwardLimitSwitchDeviceIDDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def forwardLimitSwitchDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def forwardLimitSwitchNormalDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def forwardLimitSwitchSourceDifferent(settings: BaseTalonConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def reverseLimitSwitchDeviceIDDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def reverseLimitSwitchDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def reverseLimitSwitchNormalDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def reverseLimitSwitchSourceDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def sum0TermDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    @staticmethod
    def sum1TermDifferent(settings: BaseTalonConfiguration) -> bool:
        ...
    def __init__(self) -> None:
        ...
class BaseTalonConfiguration(BaseMotorControllerConfiguration):
    """
    Configurables available to BaseTalon
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to all the configs
        
        :returns: String representation of all the configs
        """
    @property
    def auxiliaryPID(self) -> BaseTalonPIDSetConfiguration:
        """
        Auxiliary PID configuration
        """
    @auxiliaryPID.setter
    def auxiliaryPID(self, arg0: BaseTalonPIDSetConfiguration) -> None:
        ...
    @property
    def diff0Term(self) -> FeedbackDevice:
        """
        Feedback Device for Diff 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *	@code
        *	configs.diff0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *	configs.diff0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *	@endcode
        """
    @diff0Term.setter
    def diff0Term(self, arg0: FeedbackDevice) -> None:
        ...
    @property
    def diff1Term(self) -> FeedbackDevice:
        """
        Feedback Device for Diff 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *	@code
        *	configs.diff1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *	configs.diff1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *	@endcode
        """
    @diff1Term.setter
    def diff1Term(self, arg0: FeedbackDevice) -> None:
        ...
    @property
    def forwardLimitSwitchDeviceID(self) -> int:
        """
        Forward limit switch device ID
        
        Limit Switch device id isn't used unless device is a remote
        """
    @forwardLimitSwitchDeviceID.setter
    def forwardLimitSwitchDeviceID(self, arg0: int) -> None:
        ...
    @property
    def forwardLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Forward limit switch normally open/closed
        """
    @forwardLimitSwitchNormal.setter
    def forwardLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        ...
    @property
    def forwardLimitSwitchSource(self) -> LimitSwitchSource:
        """
        Forward Limit Switch Source
        
        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @forwardLimitSwitchSource.setter
    def forwardLimitSwitchSource(self, arg0: LimitSwitchSource) -> None:
        ...
    @property
    def primaryPID(self) -> BaseTalonPIDSetConfiguration:
        """
        Primary PID configuration
        """
    @primaryPID.setter
    def primaryPID(self, arg0: BaseTalonPIDSetConfiguration) -> None:
        ...
    @property
    def reverseLimitSwitchDeviceID(self) -> int:
        """
        Reverse limit switch device ID
        
        Limit Switch device id isn't used unless device is a remote
        """
    @reverseLimitSwitchDeviceID.setter
    def reverseLimitSwitchDeviceID(self, arg0: int) -> None:
        ...
    @property
    def reverseLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Reverse limit switch normally open/closed
        """
    @reverseLimitSwitchNormal.setter
    def reverseLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        ...
    @property
    def reverseLimitSwitchSource(self) -> LimitSwitchSource:
        """
        Reverse Limit Switch Source
        
        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @reverseLimitSwitchSource.setter
    def reverseLimitSwitchSource(self, arg0: LimitSwitchSource) -> None:
        ...
    @property
    def sum0Term(self) -> FeedbackDevice:
        """
        Feedback Device for Sum 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *	@code
        *	configs.sum0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *	configs.sum0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *	@endcode
        """
    @sum0Term.setter
    def sum0Term(self, arg0: FeedbackDevice) -> None:
        ...
    @property
    def sum1Term(self) -> FeedbackDevice:
        """
        Feedback Device for Sum 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *	@code
        *	configs.sum1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *	configs.sum1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *	@endcode
        """
    @sum1Term.setter
    def sum1Term(self, arg0: FeedbackDevice) -> None:
        ...
class BaseTalonPIDSetConfigUtil:
    """
    Util class to help with BaseTalon's PID configs
    """
    @staticmethod
    def selectedFeedbackCoefficientDifferent(settings: BaseTalonPIDSetConfiguration) -> bool:
        ...
    @staticmethod
    def selectedFeedbackSensorDifferent(settings: BaseTalonPIDSetConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    def __init__(self) -> None:
        ...
class BaseTalonPIDSetConfiguration(BasePIDSetConfiguration):
    """
    Configurables available to BaseTalon's PID
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: string representation of configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to configs
        
        :returns: String representation of configs
        """
    @property
    def selectedFeedbackSensor(self) -> FeedbackDevice:
        """
        Feedback device for a particular PID loop.
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        *	@code
        *	configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        *	configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        *	@endcode
        """
    @selectedFeedbackSensor.setter
    def selectedFeedbackSensor(self, arg0: FeedbackDevice) -> None:
        ...
class BufferedTrajectoryPointStream:
    """
    Stream of trajectory points for Talon/Victor motion profiling.
    """
    def __init__(self) -> None:
        ...
    def clear(self) -> ErrorCode:
        """
        Clear all trajectory points.
        
        :returns: nonzero error code if operation fails.
        """
    @typing.overload
    def write(self, trajPt: TrajectoryPoint) -> ErrorCode:
        """
        Write a single trajectory point into the buffer.
        
        :returns: nonzero error code if operation fails.
        """
    @typing.overload
    def write(self, trajPts: TrajectoryPoint, trajPtCount: int) -> ErrorCode:
        """
        Writes an array of trajectory point into the buffer.
        
        :returns: nonzero error code if operation fails.
        """
class CANBusAddressable:
    """
    Simple address holder.
    """
    def __init__(self, deviceNumber: int) -> None:
        """
        Constructor for a CANBusAddressable device
        
        :param deviceNumber: CAN Device ID of device
        """
    def getDeviceNumber(self) -> int:
        """
        :returns: CAN device number of device
        """
class CANifier(CANBusAddressable):
    """
    CTRE CANifier
    
    Device for interfacing common devices to the CAN bus.
    """
    class GeneralPin:
        """
        General IO Pins on the CANifier
        
        Members:
        
          QUAD_IDX : Quadrature Idx pin
        
          QUAD_B : Quadrature B pin
        
          QUAD_A : Quadrature A pin
        
          LIMR : Reverse limit pin
        
          LIMF : Forward limit pin
        
          SDA : SDA pin
        
          SCL : SCL pin
        
          SPI_CS : SPI_CS pin
        
          SPI_MISO_PWM2P : SPI_MISO_PWM2 pin
        
          SPI_MOSI_PWM1P : SPI_MOSI_PWM1 pin
        
          SPI_CLK_PWM0P : SPI_CLK_PWM0 pin
        """
        LIMF: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.LIMF: 4>
        LIMR: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.LIMR: 3>
        QUAD_A: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.QUAD_A: 2>
        QUAD_B: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.QUAD_B: 1>
        QUAD_IDX: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.QUAD_IDX: 0>
        SCL: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.SCL: 6>
        SDA: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.SDA: 5>
        SPI_CLK_PWM0P: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.SPI_CLK_PWM0P: 10>
        SPI_CS: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.SPI_CS: 7>
        SPI_MISO_PWM2P: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.SPI_MISO_PWM2P: 8>
        SPI_MOSI_PWM1P: typing.ClassVar[CANifier.GeneralPin]  # value = <GeneralPin.SPI_MOSI_PWM1P: 9>
        __members__: typing.ClassVar[dict[str, CANifier.GeneralPin]]  # value = {'QUAD_IDX': <GeneralPin.QUAD_IDX: 0>, 'QUAD_B': <GeneralPin.QUAD_B: 1>, 'QUAD_A': <GeneralPin.QUAD_A: 2>, 'LIMR': <GeneralPin.LIMR: 3>, 'LIMF': <GeneralPin.LIMF: 4>, 'SDA': <GeneralPin.SDA: 5>, 'SCL': <GeneralPin.SCL: 6>, 'SPI_CS': <GeneralPin.SPI_CS: 7>, 'SPI_MISO_PWM2P': <GeneralPin.SPI_MISO_PWM2P: 8>, 'SPI_MOSI_PWM1P': <GeneralPin.SPI_MOSI_PWM1P: 9>, 'SPI_CLK_PWM0P': <GeneralPin.SPI_CLK_PWM0P: 10>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class LEDChannel:
        """
        Enum for the LED Output Channels
        
        Members:
        
          A : LED Channel A
        
          B : LED Channel B
        
          C : LED Channel C
        """
        A: typing.ClassVar[CANifier.LEDChannel]  # value = <LEDChannel.A: 0>
        B: typing.ClassVar[CANifier.LEDChannel]  # value = <LEDChannel.B: 1>
        C: typing.ClassVar[CANifier.LEDChannel]  # value = <LEDChannel.C: 2>
        __members__: typing.ClassVar[dict[str, CANifier.LEDChannel]]  # value = {'A': <LEDChannel.A: 0>, 'B': <LEDChannel.B: 1>, 'C': <LEDChannel.C: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class PWMChannel:
        """
        Enum for the PWM Input Channels
        
        Members:
        
          PWMChannel0 : PWM Channel 0
        
          PWMChannel1 : PWM Channel 1
        
          PWMChannel2 : PWM Channel 2
        
          PWMChannel3 : PWM Channel 3
        """
        PWMChannel0: typing.ClassVar[CANifier.PWMChannel]  # value = <PWMChannel.PWMChannel0: 0>
        PWMChannel1: typing.ClassVar[CANifier.PWMChannel]  # value = <PWMChannel.PWMChannel1: 1>
        PWMChannel2: typing.ClassVar[CANifier.PWMChannel]  # value = <PWMChannel.PWMChannel2: 2>
        PWMChannel3: typing.ClassVar[CANifier.PWMChannel]  # value = <PWMChannel.PWMChannel3: 3>
        __members__: typing.ClassVar[dict[str, CANifier.PWMChannel]]  # value = {'PWMChannel0': <PWMChannel.PWMChannel0: 0>, 'PWMChannel1': <PWMChannel.PWMChannel1: 1>, 'PWMChannel2': <PWMChannel.PWMChannel2: 2>, 'PWMChannel3': <PWMChannel.PWMChannel3: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class PinValues:
        """
        Structure to hold the pin values.
        """
        def __init__(self) -> None:
            ...
        @property
        def LIMF(self) -> bool:
            """
            Forward limit pin
            """
        @LIMF.setter
        def LIMF(self, arg0: bool) -> None:
            ...
        @property
        def LIMR(self) -> bool:
            """
            Reverse limit pin
            """
        @LIMR.setter
        def LIMR(self, arg0: bool) -> None:
            ...
        @property
        def QUAD_A(self) -> bool:
            """
            Quadrature A pin
            """
        @QUAD_A.setter
        def QUAD_A(self, arg0: bool) -> None:
            ...
        @property
        def QUAD_B(self) -> bool:
            """
            Quadrature B pin
            """
        @QUAD_B.setter
        def QUAD_B(self, arg0: bool) -> None:
            ...
        @property
        def QUAD_IDX(self) -> bool:
            """
            Quadrature Idx pin
            """
        @QUAD_IDX.setter
        def QUAD_IDX(self, arg0: bool) -> None:
            ...
        @property
        def SCL(self) -> bool:
            """
            SCL pin
            """
        @SCL.setter
        def SCL(self, arg0: bool) -> None:
            ...
        @property
        def SDA(self) -> bool:
            """
            SDA pin
            """
        @SDA.setter
        def SDA(self, arg0: bool) -> None:
            ...
        @property
        def SPI_CLK_PWM0(self) -> bool:
            """
            SPI_CLK_PWM0 pin
            """
        @SPI_CLK_PWM0.setter
        def SPI_CLK_PWM0(self, arg0: bool) -> None:
            ...
        @property
        def SPI_CS_PWM3(self) -> bool:
            """
            SPI_CS_PWM3 pin
            """
        @SPI_CS_PWM3.setter
        def SPI_CS_PWM3(self, arg0: bool) -> None:
            ...
        @property
        def SPI_MISO_PWM2(self) -> bool:
            """
            SPI_MISO_PWM2 pin
            """
        @SPI_MISO_PWM2.setter
        def SPI_MISO_PWM2(self, arg0: bool) -> None:
            ...
        @property
        def SPI_MOSI_PWM1(self) -> bool:
            """
            SPI_MOSI_PWM1 pin
            """
        @SPI_MOSI_PWM1.setter
        def SPI_MOSI_PWM1(self, arg0: bool) -> None:
            ...
    @staticmethod
    def destroyAllCANifiers() -> None:
        """
        Destructs all CANifier objects
        """
    def __init__(self, deviceNumber: int) -> None:
        """
        Constructor.
        
        :param deviceNumber: The CAN Device ID of the CANifier.
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode:
        """
        Clears the Sticky Faults
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAllSettings(self, allConfigs: CANifierConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures all persistent settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered
        
        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered
        
        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected
        
        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures all persistent settings to defaults (overloaded so timeoutMs is 50 ms).
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int:
        """
        Gets the value of a custom parameter. This is for arbitrary use.
        
        Sometimes it is necessary to save calibration/duty cycle/output
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.
        
        :param paramIndex: Index of custom parameter. [0-1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float:
        """
        Gets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.
        
        :param param:     Parameter enumeration.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Value of parameter.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, valueToSend: int, ordinal: int, timeoutMs: int) -> tuple[ErrorCode, int, int]:
        """
        Gets a parameter by passing an int by reference
        
        :param param:         Parameter enumeration
        :param valueToSend:   Value to send to parameter
        :param valueReceived: Reference to integer to receive
        :param subValue:      SubValue of parameter
        :param ordinal:       Ordinal of parameter
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the value of a custom parameter. This is for arbitrary use.
        
        Sometimes it is necessary to save calibration/duty cycle/output
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.
        
        :param newValue:   Value for custom parameter.
        :param paramIndex: Index of custom parameter. [0-1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.
        
        :param param:     Parameter enumeration.
        :param value:     Value of parameter.
        :param subValue:  Subvalue for parameter. Maximum value of 255.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: sensors.SensorVelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the period of each velocity sample.
        Every 1ms a position value is sampled, and the delta between that sample
        and the position sampled kPeriod ms ago is inserted into a filter.
        kPeriod is configured with this function.
        
        :param period:    Desired period for the velocity measurement.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.
        
        :param windowSize: Number of samples in the rolling average of velocity
                           measurement. Valid values are 1,2,4,8,16,32. If another
                           value is specified, it will truncate to nearest support value.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def enablePWMOutput(self, pwmChannel: int, bEnable: bool) -> ErrorCode:
        """
        Enables PWM Outputs
        Currently supports PWM 0, PWM 1, and PWM 2
        
        :param pwmChannel: Index of the PWM channel to enable.
        :param bEnable:    True" enables output on the pwm channel.
        """
    def getAllConfigs(self, allConfigs: CANifierConfiguration, timeoutMs: int = 50) -> None:
        """
        Gets all persistant settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getBusVoltage(self) -> float:
        """
        Gets the bus voltage seen by the device.
        
        :returns: The bus voltage value (in volts).
        """
    def getFaults(self, toFill: CANifierFaults) -> ErrorCode:
        """
        Gets the CANifier fault status
        
        :param toFill: Container for fault statuses.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getFirmwareVersion(self) -> int:
        """
        Gets the firmware version of the device.
        
        :returns: Firmware version of device.
        """
    def getGeneralInput(self, inputPin: CANifier.GeneralPin) -> bool:
        """
        Gets the state of the specified pin
        
        :param inputPin: The index of the pin.
        
        :returns: The state of the pin.
        """
    def getGeneralInputs(self, allPins: CANifier.PinValues) -> ErrorCode:
        """
        Gets the state of all General Pins
        
        :param allPins: A structure to fill with the current state of all pins.
        """
    def getLastError(self) -> ErrorCode:
        """
        Call GetLastError() generated by this object.
        Not all functions return an error code but can
        potentially report errors.
        
        This function can be used to retrieve those error codes.
        
        :returns: The last ErrorCode generated.
        """
    def getPWMInput(self, pwmChannel: CANifier.PWMChannel) -> tuple[ErrorCode, typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]]:
        """
        Gets the PWM Input
        
        :param pwmChannel:          PWM channel to get.
        :param pulseWidthAndPeriod: Double array to hold Duty Cycle [0] and Period [1].
        """
    def getQuadraturePosition(self) -> int:
        """
        Gets the quadrature encoder's position
        
        :returns: Position of encoder
        """
    def getQuadratureVelocity(self) -> int:
        """
        Gets the quadrature encoder's velocity
        
        :returns: Velocity of encoder
        """
    def getStatusFramePeriod(self, frame: CANifierStatusFrame, timeoutMs: int = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: CANifierStickyFaults) -> ErrorCode:
        """
        Gets the CANifier sticky fault status
        
        :param toFill: Container for sticky fault statuses.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def hasResetOccurred(self) -> bool:
        """
        Returns true if the device has reset since last call.
        
        :returns: Has a Device Reset Occurred?
        """
    def setControlFramePeriod(self, frame: CANifierControlFrame, periodMs: int) -> ErrorCode:
        """
        Sets the period of the given control frame.
        
        :param frame:    Frame whose period is to be changed.
        :param periodMs: Period in ms for the given frame.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setGeneralOutput(self, outputPin: CANifier.GeneralPin, outputValue: bool, outputEnable: bool) -> ErrorCode:
        """
        Sets the output of a General Pin
        
        :param outputPin:    The pin to use as output.
        :param outputValue:  The desired output state.
        :param outputEnable: Whether this pin is an output. "True" enables output.
        """
    def setGeneralOutputs(self, outputBits: int, isOutputBits: int) -> ErrorCode:
        """
        Sets the output of all General Pins
        
        :param outputBits:   A bit mask of all the output states.  LSB->MSB is in the order of the #GeneralPin enum.
        :param isOutputBits: A boolean bit mask that sets the pins to be outputs or inputs.  A bit of 1 enables output.
        """
    def setLEDOutput(self, percentOutput: float, ledChannel: CANifier.LEDChannel) -> ErrorCode:
        """
        Sets the LED Output
        
        :param percentOutput: Output duty cycle expressed as percentage.
        :param ledChannel:    Channel to set the output of.
        """
    def setPWMOutput(self, pwmChannel: int, dutyCycle: float) -> ErrorCode:
        """
        Sets the PWM Output
        Currently supports PWM 0, PWM 1, and PWM 2
        
        :param pwmChannel: Index of the PWM channel to output.
        :param dutyCycle:  Duty Cycle (0 to 1) to output.  Default period of the signal is 4.2 ms.
        """
    def setQuadraturePosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the quadrature encoder's position
        
        :param newPosition: Position to set
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setStatusFramePeriod(self, statusFrame: CANifierStatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period of the given status frame.
        
        :param statusFrame: Frame whose period is to be changed.
        :param periodMs:    Period in ms for the given frame.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @property
    def PWMChannelCount(self) -> int:
        """
        Number of PWM channels available to CANifier
        """
class CANifierConfigUtils:
    """
    Util class to help with configuring CANifier
    """
    @staticmethod
    def clearPositionOnLimitFDifferent(settings: CANifierConfiguration) -> bool:
        ...
    @staticmethod
    def clearPositionOnLimitRDifferent(settings: CANifierConfiguration) -> bool:
        ...
    @staticmethod
    def clearPositionOnQuadIdxDifferent(settings: CANifierConfiguration) -> bool:
        ...
    @staticmethod
    def customParam0Different(settings: CANifierConfiguration) -> bool:
        ...
    @staticmethod
    def customParam1Different(settings: CANifierConfiguration) -> bool:
        ...
    @staticmethod
    def velocityMeasurementPeriodDifferent(settings: CANifierConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def velocityMeasurementWindowDifferent(settings: CANifierConfiguration) -> bool:
        ...
    def __init__(self) -> None:
        ...
class CANifierConfiguration(CustomParamConfiguration):
    """
    Configurables available to CANifier
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to configs
        
        :returns: String representation of configs
        """
    @property
    def clearPositionOnLimitF(self) -> bool:
        """
        Whether to clear sensor position on forward limit
        """
    @clearPositionOnLimitF.setter
    def clearPositionOnLimitF(self, arg0: bool) -> None:
        ...
    @property
    def clearPositionOnLimitR(self) -> bool:
        """
        Whether to clear sensor position on reverse limit
        """
    @clearPositionOnLimitR.setter
    def clearPositionOnLimitR(self, arg0: bool) -> None:
        ...
    @property
    def clearPositionOnQuadIdx(self) -> bool:
        """
        Whether to clear sensor position on index
        """
    @clearPositionOnQuadIdx.setter
    def clearPositionOnQuadIdx(self, arg0: bool) -> None:
        ...
    @property
    def velocityMeasurementPeriod(self) -> sensors.SensorVelocityMeasPeriod:
        """
        Velocity measurement period to use
        """
    @velocityMeasurementPeriod.setter
    def velocityMeasurementPeriod(self, arg0: sensors.SensorVelocityMeasPeriod) -> None:
        ...
    @property
    def velocityMeasurementWindow(self) -> int:
        """
        Velocity measurement window to use
        """
    @velocityMeasurementWindow.setter
    def velocityMeasurementWindow(self, arg0: int) -> None:
        ...
class CANifierControlFrame:
    """
    Enumerated type for status frame types.
    
    Members:
    
      CANifier_Control_1_General
    
      CANifier_Control_2_PwmOutput
    """
    CANifier_Control_1_General: typing.ClassVar[CANifierControlFrame]  # value = <CANifierControlFrame.CANifier_Control_1_General: 50593792>
    CANifier_Control_2_PwmOutput: typing.ClassVar[CANifierControlFrame]  # value = <CANifierControlFrame.CANifier_Control_2_PwmOutput: 50593856>
    __members__: typing.ClassVar[dict[str, CANifierControlFrame]]  # value = {'CANifier_Control_1_General': <CANifierControlFrame.CANifier_Control_1_General: 50593792>, 'CANifier_Control_2_PwmOutput': <CANifierControlFrame.CANifier_Control_2_PwmOutput: 50593856>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CANifierFaults:
    """
    Faults available to CANifier (Currently has none)
    """
    @typing.overload
    def __init__(self, bits: int) -> None:
        """
        Updates current fault list with specified bit field of faults
        
        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self) -> None:
        ...
    def hasAnyFault(self) -> bool:
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int:
        """
        :returns: Current fault list as a bit field
        """
class CANifierStatusFrame:
    """
    Enumerated type for status frame types.
    
    Members:
    
      Status_1_General
    
      Status_2_General
    
      Status_3_PwmInputs0
    
      Status_4_PwmInputs1
    
      Status_5_PwmInputs2
    
      Status_6_PwmInputs3
    
      Status_8_Misc
    """
    Status_1_General: typing.ClassVar[CANifierStatusFrame]  # value = <CANifierStatusFrame.Status_1_General: 267264>
    Status_2_General: typing.ClassVar[CANifierStatusFrame]  # value = <CANifierStatusFrame.Status_2_General: 267328>
    Status_3_PwmInputs0: typing.ClassVar[CANifierStatusFrame]  # value = <CANifierStatusFrame.Status_3_PwmInputs0: 267392>
    Status_4_PwmInputs1: typing.ClassVar[CANifierStatusFrame]  # value = <CANifierStatusFrame.Status_4_PwmInputs1: 267456>
    Status_5_PwmInputs2: typing.ClassVar[CANifierStatusFrame]  # value = <CANifierStatusFrame.Status_5_PwmInputs2: 267520>
    Status_6_PwmInputs3: typing.ClassVar[CANifierStatusFrame]  # value = <CANifierStatusFrame.Status_6_PwmInputs3: 267584>
    Status_8_Misc: typing.ClassVar[CANifierStatusFrame]  # value = <CANifierStatusFrame.Status_8_Misc: 267712>
    __members__: typing.ClassVar[dict[str, CANifierStatusFrame]]  # value = {'Status_1_General': <CANifierStatusFrame.Status_1_General: 267264>, 'Status_2_General': <CANifierStatusFrame.Status_2_General: 267328>, 'Status_3_PwmInputs0': <CANifierStatusFrame.Status_3_PwmInputs0: 267392>, 'Status_4_PwmInputs1': <CANifierStatusFrame.Status_4_PwmInputs1: 267456>, 'Status_5_PwmInputs2': <CANifierStatusFrame.Status_5_PwmInputs2: 267520>, 'Status_6_PwmInputs3': <CANifierStatusFrame.Status_6_PwmInputs3: 267584>, 'Status_8_Misc': <CANifierStatusFrame.Status_8_Misc: 267712>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CANifierStickyFaults:
    """
    Sticky Faults for CANifier (Currently has none)
    """
    @typing.overload
    def __init__(self, bits: int) -> None:
        """
        Updates current fault list with specified bit field of faults
        
        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self) -> None:
        ...
    def hasAnyFault(self) -> bool:
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int:
        """
        :returns: Current fault list as a bit field
        """
class CANifierVelocityMeasPeriod:
    """
    Enum for velocity periods used for CANifier
    
    Members:
    
      Period_1Ms : 1ms velocity measurement period
    
      Period_2Ms : 2ms velocity measurement period
    
      Period_5Ms : 5ms velocity measurement period
    
      Period_10Ms : 10ms velocity measurement period
    
      Period_20Ms : 20ms velocity measurement period
    
      Period_25Ms : 25ms velocity measurement period
    
      Period_50Ms : 50ms velocity measurement period
    
      Period_100Ms : 100ms velocity measurement period
    """
    Period_100Ms: typing.ClassVar[CANifierVelocityMeasPeriod]  # value = <CANifierVelocityMeasPeriod.Period_100Ms: 100>
    Period_10Ms: typing.ClassVar[CANifierVelocityMeasPeriod]  # value = <CANifierVelocityMeasPeriod.Period_10Ms: 10>
    Period_1Ms: typing.ClassVar[CANifierVelocityMeasPeriod]  # value = <CANifierVelocityMeasPeriod.Period_1Ms: 1>
    Period_20Ms: typing.ClassVar[CANifierVelocityMeasPeriod]  # value = <CANifierVelocityMeasPeriod.Period_20Ms: 20>
    Period_25Ms: typing.ClassVar[CANifierVelocityMeasPeriod]  # value = <CANifierVelocityMeasPeriod.Period_25Ms: 25>
    Period_2Ms: typing.ClassVar[CANifierVelocityMeasPeriod]  # value = <CANifierVelocityMeasPeriod.Period_2Ms: 2>
    Period_50Ms: typing.ClassVar[CANifierVelocityMeasPeriod]  # value = <CANifierVelocityMeasPeriod.Period_50Ms: 50>
    Period_5Ms: typing.ClassVar[CANifierVelocityMeasPeriod]  # value = <CANifierVelocityMeasPeriod.Period_5Ms: 5>
    __members__: typing.ClassVar[dict[str, CANifierVelocityMeasPeriod]]  # value = {'Period_1Ms': <CANifierVelocityMeasPeriod.Period_1Ms: 1>, 'Period_2Ms': <CANifierVelocityMeasPeriod.Period_2Ms: 2>, 'Period_5Ms': <CANifierVelocityMeasPeriod.Period_5Ms: 5>, 'Period_10Ms': <CANifierVelocityMeasPeriod.Period_10Ms: 10>, 'Period_20Ms': <CANifierVelocityMeasPeriod.Period_20Ms: 20>, 'Period_25Ms': <CANifierVelocityMeasPeriod.Period_25Ms: 25>, 'Period_50Ms': <CANifierVelocityMeasPeriod.Period_50Ms: 50>, 'Period_100Ms': <CANifierVelocityMeasPeriod.Period_100Ms: 100>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ControlFrame:
    """
    Control Frames for motor controllers
    
    Members:
    
      Control_3_General : Control
    
      Control_4_Advanced : Advanced Control
    
      Control_6_MotProfAddTrajPoint : Trajectory points
    """
    Control_3_General: typing.ClassVar[ControlFrame]  # value = <ControlFrame.Control_3_General: 262272>
    Control_4_Advanced: typing.ClassVar[ControlFrame]  # value = <ControlFrame.Control_4_Advanced: 262336>
    Control_6_MotProfAddTrajPoint: typing.ClassVar[ControlFrame]  # value = <ControlFrame.Control_6_MotProfAddTrajPoint: 262464>
    __members__: typing.ClassVar[dict[str, ControlFrame]]  # value = {'Control_3_General': <ControlFrame.Control_3_General: 262272>, 'Control_4_Advanced': <ControlFrame.Control_4_Advanced: 262336>, 'Control_6_MotProfAddTrajPoint': <ControlFrame.Control_6_MotProfAddTrajPoint: 262464>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ControlFrameEnhanced:
    """
    Control Frames for enhanced motor controllers
    
    Members:
    
      Control_3_General_ : Control
    
      Control_4_Advanced_ : Advanced Control
    
      Control_5_FeedbackOutputOverride_ : Override feedback output
    
      Control_6_MotProfAddTrajPoint_ : Trajectory points
    """
    Control_3_General_: typing.ClassVar[ControlFrameEnhanced]  # value = <ControlFrameEnhanced.Control_3_General_: 262272>
    Control_4_Advanced_: typing.ClassVar[ControlFrameEnhanced]  # value = <ControlFrameEnhanced.Control_4_Advanced_: 262336>
    Control_5_FeedbackOutputOverride_: typing.ClassVar[ControlFrameEnhanced]  # value = <ControlFrameEnhanced.Control_5_FeedbackOutputOverride_: 262400>
    Control_6_MotProfAddTrajPoint_: typing.ClassVar[ControlFrameEnhanced]  # value = <ControlFrameEnhanced.Control_6_MotProfAddTrajPoint_: 262464>
    __members__: typing.ClassVar[dict[str, ControlFrameEnhanced]]  # value = {'Control_3_General_': <ControlFrameEnhanced.Control_3_General_: 262272>, 'Control_4_Advanced_': <ControlFrameEnhanced.Control_4_Advanced_: 262336>, 'Control_5_FeedbackOutputOverride_': <ControlFrameEnhanced.Control_5_FeedbackOutputOverride_: 262400>, 'Control_6_MotProfAddTrajPoint_': <ControlFrameEnhanced.Control_6_MotProfAddTrajPoint_: 262464>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ControlMode:
    """
    Choose the control mode for a motor controller.
    Consult product specific documentation to determine what is available/supported.
    
    Members:
    
      PercentOutput : Percent output [-1,1]
    
      Position : Position closed loop
    
      Velocity : Velocity closed loop
    
      Current : Input current closed loop
    
      Follower : Follow other motor controller
    
      MotionProfile : Motion Profile
    
      MotionMagic : Motion Magic
    
      MotionProfileArc : Motion Profile with auxiliary output
    
      MusicTone : Plays a single tone.  Frequency (hz) is passed into set.
    
      Disabled : Disable Motor Controller
    """
    Current: typing.ClassVar[ControlMode]  # value = <ControlMode.Current: 3>
    Disabled: typing.ClassVar[ControlMode]  # value = <ControlMode.Disabled: 15>
    Follower: typing.ClassVar[ControlMode]  # value = <ControlMode.Follower: 5>
    MotionMagic: typing.ClassVar[ControlMode]  # value = <ControlMode.MotionMagic: 7>
    MotionProfile: typing.ClassVar[ControlMode]  # value = <ControlMode.MotionProfile: 6>
    MotionProfileArc: typing.ClassVar[ControlMode]  # value = <ControlMode.MotionProfileArc: 10>
    MusicTone: typing.ClassVar[ControlMode]  # value = <ControlMode.MusicTone: 13>
    PercentOutput: typing.ClassVar[ControlMode]  # value = <ControlMode.PercentOutput: 0>
    Position: typing.ClassVar[ControlMode]  # value = <ControlMode.Position: 1>
    Velocity: typing.ClassVar[ControlMode]  # value = <ControlMode.Velocity: 2>
    __members__: typing.ClassVar[dict[str, ControlMode]]  # value = {'PercentOutput': <ControlMode.PercentOutput: 0>, 'Position': <ControlMode.Position: 1>, 'Velocity': <ControlMode.Velocity: 2>, 'Current': <ControlMode.Current: 3>, 'Follower': <ControlMode.Follower: 5>, 'MotionProfile': <ControlMode.MotionProfile: 6>, 'MotionMagic': <ControlMode.MotionMagic: 7>, 'MotionProfileArc': <ControlMode.MotionProfileArc: 10>, 'MusicTone': <ControlMode.MusicTone: 13>, 'Disabled': <ControlMode.Disabled: 15>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CustomParamConfigUtil:
    """
    Util class to help custom configs
    """
    @staticmethod
    def customParam0Different(settings: CustomParamConfiguration) -> bool:
        """
        :param settings: Settings to compare against
        
        :returns: Whether CustomParam0 is different
        """
    @staticmethod
    def customParam1Different(settings: CustomParamConfiguration) -> bool:
        """
        :param settings: Settings to compare against
        
        :returns: Whether CustomParam1 is different
        """
    def __init__(self) -> None:
        ...
class CustomParamConfiguration:
    """
    Configurables for any custom param configs
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: string representation of currently selected configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to all the configs
        
        :returns: string representation fo currently selected configs
        """
    @property
    def customParam0(self) -> int:
        """
        Custom Param 0
        """
    @customParam0.setter
    def customParam0(self, arg0: int) -> None:
        ...
    @property
    def customParam1(self) -> int:
        """
        Custom Param 1
        """
    @customParam1.setter
    def customParam1(self, arg0: int) -> None:
        ...
    @property
    def enableOptimizations(self) -> bool:
        """
        Enable optimizations for ConfigAll (defaults true)
        """
    @enableOptimizations.setter
    def enableOptimizations(self, arg0: bool) -> None:
        ...
class DemandType:
    """
    How to interpret a demand value.
    
    Members:
    
      Neutral : Ignore the demand value and apply neutral/no-change.
    
      AuxPID : When closed-looping, set the target of the aux PID loop to the demand value.
    
    When following, follow the processed output of the combined
    primary/aux PID output of the master.  The demand value is ignored.
    Although it is much cleaner to use the 2-param Follow() in such cases.
    
      ArbitraryFeedForward : When closed-looping, add demand arbitrarily to the closed-loop output.
    """
    ArbitraryFeedForward: typing.ClassVar[DemandType]  # value = <DemandType.ArbitraryFeedForward: 2>
    AuxPID: typing.ClassVar[DemandType]  # value = <DemandType.AuxPID: 1>
    Neutral: typing.ClassVar[DemandType]  # value = <DemandType.Neutral: 0>
    __members__: typing.ClassVar[dict[str, DemandType]]  # value = {'Neutral': <DemandType.Neutral: 0>, 'AuxPID': <DemandType.AuxPID: 1>, 'ArbitraryFeedForward': <DemandType.ArbitraryFeedForward: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ErrorCode:
    """
    Members:
    
      OK
    
      OKAY : No Error - Function executed as expected
    
      CAN_MSG_STALE
    
      CAN_TX_FULL
    
      TxFailed : Could not transmit the CAN frame.
    
      InvalidParamValue : Caller passed an invalid param
    
      CAN_INVALID_PARAM
    
      RxTimeout : CAN frame has not been received within specified period of time.
    
      CAN_MSG_NOT_FOUND
    
      TxTimeout : Not used.
    
      CAN_NO_MORE_TX_JOBS
    
      UnexpectedArbId : Specified CAN Id is invalid.
    
      CAN_NO_SESSIONS_AVAIL
    
      BufferFull : Caller attempted to insert data into a buffer that is full.
    
      CAN_OVERFLOW
    
      SensorNotPresent : Sensor is not present
    
      FirmwareTooOld
    
      CouldNotChangePeriod
    
      BufferFailure
    
      FirwmwareNonFRC
    
      GeneralError : User Specified General Error
    
      GENERAL_ERROR
    
      SIG_NOT_UPDATED
    
      SigNotUpdated : Have not received an value response for signal.
    
      NotAllPIDValuesUpdated
    
      GEN_PORT_ERROR
    
      PORT_MODULE_TYPE_MISMATCH
    
      GEN_MODULE_ERROR
    
      MODULE_NOT_INIT_SET_ERROR
    
      MODULE_NOT_INIT_GET_ERROR
    
      WheelRadiusTooSmall
    
      TicksPerRevZero
    
      DistanceBetweenWheelsTooSmall
    
      GainsAreNotSet
    
      WrongRemoteLimitSwitchSource
    
      DoubleVoltageCompensatingWPI
    
      CANdleAnimSlotOutOfBounds
    
      IncompatibleMode
    
      InvalidHandle : Handle does not match stored map of handles
    
      FeatureRequiresHigherFirm
    
      MotorControllerFeatureRequiresHigherFirm
    
      TalonFeatureRequiresHigherFirm
    
      ConfigFactoryDefaultRequiresHigherFirm
    
      ConfigMotionSCurveRequiresHigherFirm
    
      TalonFXFirmwarePreVBatDetect
    
      CANdleAnimationsRequireHigherFirm
    
      LibraryCouldNotBeLoaded
    
      MissingRoutineInLibrary
    
      ResourceNotAvailable
    
      MusicFileNotFound
    
      MusicFileWrongSize
    
      MusicFileTooNew
    
      MusicFileInvalid
    
      InvalidOrchestraAction
    
      MusicFileTooOld
    
      MusicInterrupted
    
      MusicNotSupported
    
      kInvalidInterface
    
      kInvalidGuid
    
      kInvalidClass
    
      kInvalidProtocol
    
      kInvalidPath
    
      kGeneralWinUsbError
    
      kFailedSetup
    
      kListenFailed
    
      kSendFailed
    
      kReceiveFailed
    
      kInvalidRespFormat
    
      kWinUsbInitFailed
    
      kWinUsbQueryFailed
    
      kWinUsbGeneralError
    
      kAccessDenied
    
      kFirmwareInvalidResponse
    
      PulseWidthSensorNotPresent : Special Code for "isSensorPresent"
    
      GeneralWarning
    
      FeatureNotSupported
    
      NotImplemented
    
      FirmVersionCouldNotBeRetrieved
    
      FeaturesNotAvailableYet
    
      ControlModeNotValid
    
      ControlModeNotSupportedYet
    
      CascadedPIDNotSupporteYet
    
      AuxiliaryPIDNotSupportedYet
    
      RemoteSensorsNotSupportedYet
    
      MotProfFirmThreshold
    
      MotProfFirmThreshold2
    
      SimDeviceNotFound
    
      SimPhysicsTypeNotSupported
    
      SimDeviceAlreadyExists
    """
    AuxiliaryPIDNotSupportedYet: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CascadedPIDNotSupporteYet: 107>
    BufferFailure: typing.ClassVar[ErrorCode]  # value = <ErrorCode.BufferFailure: -10>
    BufferFull: typing.ClassVar[ErrorCode]  # value = <ErrorCode.BufferFull: 6>
    CAN_INVALID_PARAM: typing.ClassVar[ErrorCode]  # value = <ErrorCode.InvalidParamValue: -2>
    CAN_MSG_NOT_FOUND: typing.ClassVar[ErrorCode]  # value = <ErrorCode.RxTimeout: -3>
    CAN_MSG_STALE: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CAN_MSG_STALE: 1>
    CAN_NO_MORE_TX_JOBS: typing.ClassVar[ErrorCode]  # value = <ErrorCode.TxTimeout: -4>
    CAN_NO_SESSIONS_AVAIL: typing.ClassVar[ErrorCode]  # value = <ErrorCode.UnexpectedArbId: -5>
    CAN_OVERFLOW: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CAN_OVERFLOW: -6>
    CAN_TX_FULL: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CAN_TX_FULL: -1>
    CANdleAnimSlotOutOfBounds: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CANdleAnimSlotOutOfBounds: -506>
    CANdleAnimationsRequireHigherFirm: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CANdleAnimationsRequireHigherFirm: -705>
    CascadedPIDNotSupporteYet: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CascadedPIDNotSupporteYet: 107>
    ConfigFactoryDefaultRequiresHigherFirm: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ConfigFactoryDefaultRequiresHigherFirm: -702>
    ConfigMotionSCurveRequiresHigherFirm: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ConfigMotionSCurveRequiresHigherFirm: -703>
    ControlModeNotSupportedYet: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ControlModeNotSupportedYet: 106>
    ControlModeNotValid: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ControlModeNotValid: 105>
    CouldNotChangePeriod: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CouldNotChangePeriod: -9>
    DistanceBetweenWheelsTooSmall: typing.ClassVar[ErrorCode]  # value = <ErrorCode.DistanceBetweenWheelsTooSmall: -502>
    DoubleVoltageCompensatingWPI: typing.ClassVar[ErrorCode]  # value = <ErrorCode.DoubleVoltageCompensatingWPI: -505>
    FeatureNotSupported: typing.ClassVar[ErrorCode]  # value = <ErrorCode.FeatureNotSupported: 101>
    FeatureRequiresHigherFirm: typing.ClassVar[ErrorCode]  # value = <ErrorCode.FeatureRequiresHigherFirm: -700>
    FeaturesNotAvailableYet: typing.ClassVar[ErrorCode]  # value = <ErrorCode.FeaturesNotAvailableYet: 104>
    FirmVersionCouldNotBeRetrieved: typing.ClassVar[ErrorCode]  # value = <ErrorCode.FirmVersionCouldNotBeRetrieved: 103>
    FirmwareTooOld: typing.ClassVar[ErrorCode]  # value = <ErrorCode.FirmwareTooOld: -8>
    FirwmwareNonFRC: typing.ClassVar[ErrorCode]  # value = <ErrorCode.FirwmwareNonFRC: -11>
    GENERAL_ERROR: typing.ClassVar[ErrorCode]  # value = <ErrorCode.GeneralError: -100>
    GEN_MODULE_ERROR: typing.ClassVar[ErrorCode]  # value = <ErrorCode.GEN_MODULE_ERROR: -400>
    GEN_PORT_ERROR: typing.ClassVar[ErrorCode]  # value = <ErrorCode.GEN_PORT_ERROR: -300>
    GainsAreNotSet: typing.ClassVar[ErrorCode]  # value = <ErrorCode.GainsAreNotSet: -503>
    GeneralError: typing.ClassVar[ErrorCode]  # value = <ErrorCode.GeneralError: -100>
    GeneralWarning: typing.ClassVar[ErrorCode]  # value = <ErrorCode.GeneralWarning: 100>
    IncompatibleMode: typing.ClassVar[ErrorCode]  # value = <ErrorCode.IncompatibleMode: -600>
    InvalidHandle: typing.ClassVar[ErrorCode]  # value = <ErrorCode.InvalidHandle: -601>
    InvalidOrchestraAction: typing.ClassVar[ErrorCode]  # value = <ErrorCode.InvalidOrchestraAction: -904>
    InvalidParamValue: typing.ClassVar[ErrorCode]  # value = <ErrorCode.InvalidParamValue: -2>
    LibraryCouldNotBeLoaded: typing.ClassVar[ErrorCode]  # value = <ErrorCode.LibraryCouldNotBeLoaded: -800>
    MODULE_NOT_INIT_GET_ERROR: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MODULE_NOT_INIT_GET_ERROR: -402>
    MODULE_NOT_INIT_SET_ERROR: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MODULE_NOT_INIT_SET_ERROR: -401>
    MissingRoutineInLibrary: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MissingRoutineInLibrary: -801>
    MotProfFirmThreshold: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MotProfFirmThreshold: 109>
    MotProfFirmThreshold2: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MotProfFirmThreshold2: 110>
    MotorControllerFeatureRequiresHigherFirm: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MotorControllerFeatureRequiresHigherFirm: -701>
    MusicFileInvalid: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MusicFileInvalid: -903>
    MusicFileNotFound: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MusicFileNotFound: -900>
    MusicFileTooNew: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MusicFileTooNew: -902>
    MusicFileTooOld: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MusicFileTooOld: -905>
    MusicFileWrongSize: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MusicFileWrongSize: -901>
    MusicInterrupted: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MusicInterrupted: -906>
    MusicNotSupported: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MusicNotSupported: -907>
    NotAllPIDValuesUpdated: typing.ClassVar[ErrorCode]  # value = <ErrorCode.NotAllPIDValuesUpdated: -201>
    NotImplemented: typing.ClassVar[ErrorCode]  # value = <ErrorCode.NotImplemented: 102>
    OK: typing.ClassVar[ErrorCode]  # value = <ErrorCode.OK: 0>
    OKAY: typing.ClassVar[ErrorCode]  # value = <ErrorCode.OK: 0>
    PORT_MODULE_TYPE_MISMATCH: typing.ClassVar[ErrorCode]  # value = <ErrorCode.PORT_MODULE_TYPE_MISMATCH: -301>
    PulseWidthSensorNotPresent: typing.ClassVar[ErrorCode]  # value = <ErrorCode.PulseWidthSensorNotPresent: 10>
    RemoteSensorsNotSupportedYet: typing.ClassVar[ErrorCode]  # value = <ErrorCode.RemoteSensorsNotSupportedYet: 108>
    ResourceNotAvailable: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ResourceNotAvailable: -802>
    RxTimeout: typing.ClassVar[ErrorCode]  # value = <ErrorCode.RxTimeout: -3>
    SIG_NOT_UPDATED: typing.ClassVar[ErrorCode]  # value = <ErrorCode.SIG_NOT_UPDATED: -200>
    SensorNotPresent: typing.ClassVar[ErrorCode]  # value = <ErrorCode.SensorNotPresent: -7>
    SigNotUpdated: typing.ClassVar[ErrorCode]  # value = <ErrorCode.SIG_NOT_UPDATED: -200>
    SimDeviceAlreadyExists: typing.ClassVar[ErrorCode]  # value = <ErrorCode.SimDeviceAlreadyExists: 202>
    SimDeviceNotFound: typing.ClassVar[ErrorCode]  # value = <ErrorCode.SimDeviceNotFound: 200>
    SimPhysicsTypeNotSupported: typing.ClassVar[ErrorCode]  # value = <ErrorCode.SimPhysicsTypeNotSupported: 201>
    TalonFXFirmwarePreVBatDetect: typing.ClassVar[ErrorCode]  # value = <ErrorCode.TalonFXFirmwarePreVBatDetect: -704>
    TalonFeatureRequiresHigherFirm: typing.ClassVar[ErrorCode]  # value = <ErrorCode.MotorControllerFeatureRequiresHigherFirm: -701>
    TicksPerRevZero: typing.ClassVar[ErrorCode]  # value = <ErrorCode.TicksPerRevZero: -501>
    TxFailed: typing.ClassVar[ErrorCode]  # value = <ErrorCode.CAN_TX_FULL: -1>
    TxTimeout: typing.ClassVar[ErrorCode]  # value = <ErrorCode.TxTimeout: -4>
    UnexpectedArbId: typing.ClassVar[ErrorCode]  # value = <ErrorCode.UnexpectedArbId: -5>
    WheelRadiusTooSmall: typing.ClassVar[ErrorCode]  # value = <ErrorCode.WheelRadiusTooSmall: -500>
    WrongRemoteLimitSwitchSource: typing.ClassVar[ErrorCode]  # value = <ErrorCode.WrongRemoteLimitSwitchSource: -504>
    __members__: typing.ClassVar[dict[str, ErrorCode]]  # value = {'OK': <ErrorCode.OK: 0>, 'OKAY': <ErrorCode.OK: 0>, 'CAN_MSG_STALE': <ErrorCode.CAN_MSG_STALE: 1>, 'CAN_TX_FULL': <ErrorCode.CAN_TX_FULL: -1>, 'TxFailed': <ErrorCode.CAN_TX_FULL: -1>, 'InvalidParamValue': <ErrorCode.InvalidParamValue: -2>, 'CAN_INVALID_PARAM': <ErrorCode.InvalidParamValue: -2>, 'RxTimeout': <ErrorCode.RxTimeout: -3>, 'CAN_MSG_NOT_FOUND': <ErrorCode.RxTimeout: -3>, 'TxTimeout': <ErrorCode.TxTimeout: -4>, 'CAN_NO_MORE_TX_JOBS': <ErrorCode.TxTimeout: -4>, 'UnexpectedArbId': <ErrorCode.UnexpectedArbId: -5>, 'CAN_NO_SESSIONS_AVAIL': <ErrorCode.UnexpectedArbId: -5>, 'BufferFull': <ErrorCode.BufferFull: 6>, 'CAN_OVERFLOW': <ErrorCode.CAN_OVERFLOW: -6>, 'SensorNotPresent': <ErrorCode.SensorNotPresent: -7>, 'FirmwareTooOld': <ErrorCode.FirmwareTooOld: -8>, 'CouldNotChangePeriod': <ErrorCode.CouldNotChangePeriod: -9>, 'BufferFailure': <ErrorCode.BufferFailure: -10>, 'FirwmwareNonFRC': <ErrorCode.FirwmwareNonFRC: -11>, 'GeneralError': <ErrorCode.GeneralError: -100>, 'GENERAL_ERROR': <ErrorCode.GeneralError: -100>, 'SIG_NOT_UPDATED': <ErrorCode.SIG_NOT_UPDATED: -200>, 'SigNotUpdated': <ErrorCode.SIG_NOT_UPDATED: -200>, 'NotAllPIDValuesUpdated': <ErrorCode.NotAllPIDValuesUpdated: -201>, 'GEN_PORT_ERROR': <ErrorCode.GEN_PORT_ERROR: -300>, 'PORT_MODULE_TYPE_MISMATCH': <ErrorCode.PORT_MODULE_TYPE_MISMATCH: -301>, 'GEN_MODULE_ERROR': <ErrorCode.GEN_MODULE_ERROR: -400>, 'MODULE_NOT_INIT_SET_ERROR': <ErrorCode.MODULE_NOT_INIT_SET_ERROR: -401>, 'MODULE_NOT_INIT_GET_ERROR': <ErrorCode.MODULE_NOT_INIT_GET_ERROR: -402>, 'WheelRadiusTooSmall': <ErrorCode.WheelRadiusTooSmall: -500>, 'TicksPerRevZero': <ErrorCode.TicksPerRevZero: -501>, 'DistanceBetweenWheelsTooSmall': <ErrorCode.DistanceBetweenWheelsTooSmall: -502>, 'GainsAreNotSet': <ErrorCode.GainsAreNotSet: -503>, 'WrongRemoteLimitSwitchSource': <ErrorCode.WrongRemoteLimitSwitchSource: -504>, 'DoubleVoltageCompensatingWPI': <ErrorCode.DoubleVoltageCompensatingWPI: -505>, 'CANdleAnimSlotOutOfBounds': <ErrorCode.CANdleAnimSlotOutOfBounds: -506>, 'IncompatibleMode': <ErrorCode.IncompatibleMode: -600>, 'InvalidHandle': <ErrorCode.InvalidHandle: -601>, 'FeatureRequiresHigherFirm': <ErrorCode.FeatureRequiresHigherFirm: -700>, 'MotorControllerFeatureRequiresHigherFirm': <ErrorCode.MotorControllerFeatureRequiresHigherFirm: -701>, 'TalonFeatureRequiresHigherFirm': <ErrorCode.MotorControllerFeatureRequiresHigherFirm: -701>, 'ConfigFactoryDefaultRequiresHigherFirm': <ErrorCode.ConfigFactoryDefaultRequiresHigherFirm: -702>, 'ConfigMotionSCurveRequiresHigherFirm': <ErrorCode.ConfigMotionSCurveRequiresHigherFirm: -703>, 'TalonFXFirmwarePreVBatDetect': <ErrorCode.TalonFXFirmwarePreVBatDetect: -704>, 'CANdleAnimationsRequireHigherFirm': <ErrorCode.CANdleAnimationsRequireHigherFirm: -705>, 'LibraryCouldNotBeLoaded': <ErrorCode.LibraryCouldNotBeLoaded: -800>, 'MissingRoutineInLibrary': <ErrorCode.MissingRoutineInLibrary: -801>, 'ResourceNotAvailable': <ErrorCode.ResourceNotAvailable: -802>, 'MusicFileNotFound': <ErrorCode.MusicFileNotFound: -900>, 'MusicFileWrongSize': <ErrorCode.MusicFileWrongSize: -901>, 'MusicFileTooNew': <ErrorCode.MusicFileTooNew: -902>, 'MusicFileInvalid': <ErrorCode.MusicFileInvalid: -903>, 'InvalidOrchestraAction': <ErrorCode.InvalidOrchestraAction: -904>, 'MusicFileTooOld': <ErrorCode.MusicFileTooOld: -905>, 'MusicInterrupted': <ErrorCode.MusicInterrupted: -906>, 'MusicNotSupported': <ErrorCode.MusicNotSupported: -907>, 'kInvalidInterface': <ErrorCode.kInvalidInterface: -1000>, 'kInvalidGuid': <ErrorCode.kInvalidGuid: -1001>, 'kInvalidClass': <ErrorCode.kInvalidClass: -1002>, 'kInvalidProtocol': <ErrorCode.kInvalidProtocol: -1003>, 'kInvalidPath': <ErrorCode.kInvalidPath: -1004>, 'kGeneralWinUsbError': <ErrorCode.kGeneralWinUsbError: -1005>, 'kFailedSetup': <ErrorCode.kFailedSetup: -1006>, 'kListenFailed': <ErrorCode.kListenFailed: -1007>, 'kSendFailed': <ErrorCode.kSendFailed: -1008>, 'kReceiveFailed': <ErrorCode.kReceiveFailed: -1009>, 'kInvalidRespFormat': <ErrorCode.kInvalidRespFormat: -1010>, 'kWinUsbInitFailed': <ErrorCode.kWinUsbInitFailed: -1011>, 'kWinUsbQueryFailed': <ErrorCode.kWinUsbQueryFailed: -1012>, 'kWinUsbGeneralError': <ErrorCode.kWinUsbGeneralError: -1013>, 'kAccessDenied': <ErrorCode.kAccessDenied: -1014>, 'kFirmwareInvalidResponse': <ErrorCode.kFirmwareInvalidResponse: -1015>, 'PulseWidthSensorNotPresent': <ErrorCode.PulseWidthSensorNotPresent: 10>, 'GeneralWarning': <ErrorCode.GeneralWarning: 100>, 'FeatureNotSupported': <ErrorCode.FeatureNotSupported: 101>, 'NotImplemented': <ErrorCode.NotImplemented: 102>, 'FirmVersionCouldNotBeRetrieved': <ErrorCode.FirmVersionCouldNotBeRetrieved: 103>, 'FeaturesNotAvailableYet': <ErrorCode.FeaturesNotAvailableYet: 104>, 'ControlModeNotValid': <ErrorCode.ControlModeNotValid: 105>, 'ControlModeNotSupportedYet': <ErrorCode.ControlModeNotSupportedYet: 106>, 'CascadedPIDNotSupporteYet': <ErrorCode.CascadedPIDNotSupporteYet: 107>, 'AuxiliaryPIDNotSupportedYet': <ErrorCode.CascadedPIDNotSupporteYet: 107>, 'RemoteSensorsNotSupportedYet': <ErrorCode.RemoteSensorsNotSupportedYet: 108>, 'MotProfFirmThreshold': <ErrorCode.MotProfFirmThreshold: 109>, 'MotProfFirmThreshold2': <ErrorCode.MotProfFirmThreshold2: 110>, 'SimDeviceNotFound': <ErrorCode.SimDeviceNotFound: 200>, 'SimPhysicsTypeNotSupported': <ErrorCode.SimPhysicsTypeNotSupported: 201>, 'SimDeviceAlreadyExists': <ErrorCode.SimDeviceAlreadyExists: 202>}
    kAccessDenied: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kAccessDenied: -1014>
    kFailedSetup: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kFailedSetup: -1006>
    kFirmwareInvalidResponse: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kFirmwareInvalidResponse: -1015>
    kGeneralWinUsbError: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kGeneralWinUsbError: -1005>
    kInvalidClass: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kInvalidClass: -1002>
    kInvalidGuid: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kInvalidGuid: -1001>
    kInvalidInterface: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kInvalidInterface: -1000>
    kInvalidPath: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kInvalidPath: -1004>
    kInvalidProtocol: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kInvalidProtocol: -1003>
    kInvalidRespFormat: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kInvalidRespFormat: -1010>
    kListenFailed: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kListenFailed: -1007>
    kReceiveFailed: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kReceiveFailed: -1009>
    kSendFailed: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kSendFailed: -1008>
    kWinUsbGeneralError: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kWinUsbGeneralError: -1013>
    kWinUsbInitFailed: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kWinUsbInitFailed: -1011>
    kWinUsbQueryFailed: typing.ClassVar[ErrorCode]  # value = <ErrorCode.kWinUsbQueryFailed: -1012>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Faults:
    """
    All the faults available to motor controllers
    """
    @typing.overload
    def __init__(self, bits: int) -> None:
        """
        Creates fault list with specified bit field of faults
        
        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: string representation of current faults tripped
        """
    def hasAnyFault(self) -> bool:
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int:
        """
        :returns: Current fault list as a bit field
        """
    @property
    def APIError(self) -> bool:
        """
        API error detected.  Make sure API and firmware versions are compatible.
        """
    @APIError.setter
    def APIError(self, arg0: bool) -> None:
        ...
    @property
    def ForwardLimitSwitch(self) -> bool:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited
        """
    @ForwardLimitSwitch.setter
    def ForwardLimitSwitch(self, arg0: bool) -> None:
        ...
    @property
    def ForwardSoftLimit(self) -> bool:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited
        """
    @ForwardSoftLimit.setter
    def ForwardSoftLimit(self, arg0: bool) -> None:
        ...
    @property
    def HardwareESDReset(self) -> bool:
        """
        Not used, @see ResetDuringEn
        """
    @HardwareESDReset.setter
    def HardwareESDReset(self, arg0: bool) -> None:
        ...
    @property
    def HardwareFailure(self) -> bool:
        """
        Device detects hardware failure
        """
    @HardwareFailure.setter
    def HardwareFailure(self, arg0: bool) -> None:
        ...
    @property
    def RemoteLossOfSignal(self) -> bool:
        """
        Remote Sensor is no longer detected on bus
        """
    @RemoteLossOfSignal.setter
    def RemoteLossOfSignal(self, arg0: bool) -> None:
        ...
    @property
    def ResetDuringEn(self) -> bool:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.
        """
    @ResetDuringEn.setter
    def ResetDuringEn(self, arg0: bool) -> None:
        ...
    @property
    def ReverseLimitSwitch(self) -> bool:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited
        """
    @ReverseLimitSwitch.setter
    def ReverseLimitSwitch(self, arg0: bool) -> None:
        ...
    @property
    def ReverseSoftLimit(self) -> bool:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited
        """
    @ReverseSoftLimit.setter
    def ReverseSoftLimit(self, arg0: bool) -> None:
        ...
    @property
    def SensorOutOfPhase(self) -> bool:
        """
        Device detects its sensor is out of phase
        """
    @SensorOutOfPhase.setter
    def SensorOutOfPhase(self, arg0: bool) -> None:
        ...
    @property
    def SensorOverflow(self) -> bool:
        """
        Device's sensor overflowed
        """
    @SensorOverflow.setter
    def SensorOverflow(self, arg0: bool) -> None:
        ...
    @property
    def SupplyOverV(self) -> bool:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.
        """
    @SupplyOverV.setter
    def SupplyOverV(self, arg0: bool) -> None:
        ...
    @property
    def SupplyUnstable(self) -> bool:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.
        """
    @SupplyUnstable.setter
    def SupplyUnstable(self, arg0: bool) -> None:
        ...
    @property
    def UnderVoltage(self) -> bool:
        """
        Motor Controller is under 6.5V
        """
    @UnderVoltage.setter
    def UnderVoltage(self, arg0: bool) -> None:
        ...
class FeedbackDevice:
    """
    Choose the feedback device for a motor controller.
    Consult product specific documentation to determine what is available/supported.
    
    Members:
    
      QuadEncoder : Quadrature encoder
    
      IntegratedSensor : TalonFX supports an integrated sensor.
    
      Analog : Analog potentiometer/encoder
    
      Tachometer : Tachometer
    
      PulseWidthEncodedPosition : CTRE Mag Encoder in Absolute mode or
    any other device that uses PWM to encode its output
    
      SensorSum : Sum0 + Sum1
    
      SensorDifference : Diff0 - Diff1
    
      RemoteSensor0 : Sensor configured in RemoteFilter0
    
      RemoteSensor1 : Sensor configured in RemoteFilter1
    
      None_ : Position and velocity will read 0.
    
      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.
    
      CTRE_MagEncoder_Absolute : CTR mag encoder configured in absolute, is the same
    as a PWM sensor.
    
      CTRE_MagEncoder_Relative : CTR mag encoder configured in relative, is the same
    as an quadrature encoder sensor.
    """
    Analog: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.Analog: 2>
    CTRE_MagEncoder_Absolute: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.PulseWidthEncodedPosition: 8>
    CTRE_MagEncoder_Relative: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.QuadEncoder: 0>
    IntegratedSensor: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.IntegratedSensor: 1>
    None_: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.None_: 14>
    PulseWidthEncodedPosition: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.PulseWidthEncodedPosition: 8>
    QuadEncoder: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.QuadEncoder: 0>
    RemoteSensor0: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.RemoteSensor0: 11>
    RemoteSensor1: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.RemoteSensor1: 12>
    SensorDifference: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.SensorDifference: 10>
    SensorSum: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.SensorSum: 9>
    SoftwareEmulatedSensor: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.SoftwareEmulatedSensor: 15>
    Tachometer: typing.ClassVar[FeedbackDevice]  # value = <FeedbackDevice.Tachometer: 4>
    __members__: typing.ClassVar[dict[str, FeedbackDevice]]  # value = {'QuadEncoder': <FeedbackDevice.QuadEncoder: 0>, 'IntegratedSensor': <FeedbackDevice.IntegratedSensor: 1>, 'Analog': <FeedbackDevice.Analog: 2>, 'Tachometer': <FeedbackDevice.Tachometer: 4>, 'PulseWidthEncodedPosition': <FeedbackDevice.PulseWidthEncodedPosition: 8>, 'SensorSum': <FeedbackDevice.SensorSum: 9>, 'SensorDifference': <FeedbackDevice.SensorDifference: 10>, 'RemoteSensor0': <FeedbackDevice.RemoteSensor0: 11>, 'RemoteSensor1': <FeedbackDevice.RemoteSensor1: 12>, 'None_': <FeedbackDevice.None_: 14>, 'SoftwareEmulatedSensor': <FeedbackDevice.SoftwareEmulatedSensor: 15>, 'CTRE_MagEncoder_Absolute': <FeedbackDevice.PulseWidthEncodedPosition: 8>, 'CTRE_MagEncoder_Relative': <FeedbackDevice.QuadEncoder: 0>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class FilterConfigUtil:
    """
    Util class to help with filter configs
    """
    @staticmethod
    def filterConfigurationDifferent(settings: FilterConfiguration) -> bool:
        ...
    @staticmethod
    def remoteSensorDeviceIDDifferent(settings: FilterConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def remoteSensorSourceDifferent(settings: FilterConfiguration) -> bool:
        ...
    def __init__(self) -> None:
        ...
class FilterConfiguration:
    """
    Configurations for filters
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: string representation of currently selected configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to all the configs
        
        :returns: string representation fo currently selected configs
        """
    @property
    def remoteSensorDeviceID(self) -> int:
        """
        Remote Sensor's device ID
        """
    @remoteSensorDeviceID.setter
    def remoteSensorDeviceID(self, arg0: int) -> None:
        ...
    @property
    def remoteSensorSource(self) -> RemoteSensorSource:
        """
        The remote sensor device and signal type to bind.
        """
    @remoteSensorSource.setter
    def remoteSensorSource(self, arg0: RemoteSensorSource) -> None:
        ...
class FollowerType:
    """
    Choose the type of follower
    
    Members:
    
      PercentOutput : Follow the percentOutput the master is using
    
      AuxOutput1 : Follow the auxiliary output the master is
    calculating. Used for 2-axis control.
    This typically means apply PID0 - PID1 from master.
    """
    AuxOutput1: typing.ClassVar[FollowerType]  # value = <FollowerType.AuxOutput1: 1>
    PercentOutput: typing.ClassVar[FollowerType]  # value = <FollowerType.PercentOutput: 0>
    __members__: typing.ClassVar[dict[str, FollowerType]]  # value = {'PercentOutput': <FollowerType.PercentOutput: 0>, 'AuxOutput1': <FollowerType.AuxOutput1: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class IFollower:
    """
    Interface for followers
    """
    def __init__(self) -> None:
        ...
    def follow(self, masterToFollow: IMotorController) -> None:
        """
        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX,
        Talon SRX, and Talon FX.
        
        :param masterToFollow: *						Motor Controller object to follow.
        """
    def valueUpdated(self) -> None:
        """
        When master makes a device, this routine is called to signal the update.
        """
class IGadgeteerUartClient:
    """
    Interface for uart gadgeteer devices
    """
    class GadgeteerConnection:
        """
        Method of connection to gadgeteer
        
        Members:
        
          NotConnected : Device not connected
        
          Connecting : Device in process of connecting
        
          Connected : Device is connected
        """
        Connected: typing.ClassVar[IGadgeteerUartClient.GadgeteerConnection]  # value = <GadgeteerConnection.Connected: 2>
        Connecting: typing.ClassVar[IGadgeteerUartClient.GadgeteerConnection]  # value = <GadgeteerConnection.Connecting: 1>
        NotConnected: typing.ClassVar[IGadgeteerUartClient.GadgeteerConnection]  # value = <GadgeteerConnection.NotConnected: 0>
        __members__: typing.ClassVar[dict[str, IGadgeteerUartClient.GadgeteerConnection]]  # value = {'NotConnected': <GadgeteerConnection.NotConnected: 0>, 'Connecting': <GadgeteerConnection.Connecting: 1>, 'Connected': <GadgeteerConnection.Connected: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class GadgeteerProxyType:
        """
        Device connected to gadgeteer
        
        Members:
        
          General : General Gadgeteer Proxy
        
          Pigeon : Pigeon connected to gadgeteer
        
          PC_HERO : HERO connected to gadgeteer
        """
        General: typing.ClassVar[IGadgeteerUartClient.GadgeteerProxyType]  # value = <GadgeteerProxyType.General: 0>
        PC_HERO: typing.ClassVar[IGadgeteerUartClient.GadgeteerProxyType]  # value = <GadgeteerProxyType.PC_HERO: 2>
        Pigeon: typing.ClassVar[IGadgeteerUartClient.GadgeteerProxyType]  # value = <GadgeteerProxyType.Pigeon: 1>
        __members__: typing.ClassVar[dict[str, IGadgeteerUartClient.GadgeteerProxyType]]  # value = {'General': <GadgeteerProxyType.General: 0>, 'Pigeon': <GadgeteerProxyType.Pigeon: 1>, 'PC_HERO': <GadgeteerProxyType.PC_HERO: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class GadgeteerUartStatus:
        """
        The status of the gadgeteer device
        """
        def __init__(self) -> None:
            ...
        @property
        def bitrate(self) -> int:
            """
            Bitrate of connection
            """
        @bitrate.setter
        def bitrate(self, arg0: int) -> None:
            ...
        @property
        def conn(self) -> IGadgeteerUartClient.GadgeteerConnection:
            """
            Connection status
            """
        @conn.setter
        def conn(self, arg0: IGadgeteerUartClient.GadgeteerConnection) -> None:
            ...
        @property
        def resetCount(self) -> int:
            """
            Number of resets that have happened
            """
        @resetCount.setter
        def resetCount(self, arg0: int) -> None:
            ...
        @property
        def type(self) -> IGadgeteerUartClient.GadgeteerProxyType:
            """
            Type of gadgeteer
            """
        @type.setter
        def type(self, arg0: IGadgeteerUartClient.GadgeteerProxyType) -> None:
            ...
    @staticmethod
    @typing.overload
    def toString(gpt: IGadgeteerUartClient.GadgeteerProxyType) -> str:
        """
        Gets the string representation of GadgeteerProxyType
        
        :param gpt: GadgeteerProxyType to get the string of
        
        :returns: strnig representation of GadgeteerProxyType
        """
    @staticmethod
    @typing.overload
    def toString(gc: IGadgeteerUartClient.GadgeteerConnection) -> str:
        """
        Gets the string representation of GadgeteerConnection
        
        :param gc: GadgeteerConnection to get the string of
        
        :returns: strnig representation of GadgeteerConnection
        """
    def __init__(self) -> None:
        ...
    def getGadgeteerStatus(self, status: IGadgeteerUartClient.GadgeteerUartStatus) -> int:
        """
        Gets gadgeteer status
        
        :param status: status object to fill
        
        :returns: ErrorCode
        """
class IInvertable:
    """
    Interface for invertable objects
    """
    def __init__(self) -> None:
        ...
    def getInverted(self) -> bool:
        """
        :returns: invert setting of output.
        """
    def setInverted(self, invert: bool) -> None:
        """
        Inverts the output of the object
        
        :param invert: Invert state to set.
        """
class ILoopable:
    """
    Interface for loopable objects
    """
    def __init__(self) -> None:
        ...
    def isDone(self) -> bool:
        """
        :returns: true if object is done
        """
    def onLoop(self) -> None:
        """
        Function called every loop
        """
    def onStart(self) -> None:
        """
        Function called when object starts
        """
    def onStop(self) -> None:
        """
        Function called when object stops
        """
class IMotorController(IFollower):
    """
    Interface for motor controllers
    """
    def changeMotionControlFramePeriod(self, periodMs: int) -> ErrorCode:
        """
        Calling application can opt to speed up the handshaking between the robot
        API and the controller to increase the download rate of the controller's Motion
        Profile. Ideally the period should be no more than half the period of a
        trajectory point.
        
        :param periodMs: The transmit period in ms.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileHasUnderrun(self, timeoutMs: int = 0) -> ErrorCode:
        """
        Clear the "Has Underrun" flag. Typically this is called after application
        has confirmed an underrun had occured.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileTrajectories(self) -> ErrorCode:
        """
        Clear the buffered motion profile in both controller's RAM (bottom), and in the
        API (top).
        
        :returns: Error Code generated by function. 0 indicates no error
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode:
        """
        Clears all sticky faults.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Last Error Code generated by a function.
        """
    def configAllowableClosedloopError(self, slotIdx: int, allowableCloseLoopError: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the allowable closed-loop error in the given parameter slot.
        
        :param slotIdx:                 Parameter slot for the constant.
        :param allowableCloseLoopError: Value of the allowable closed-loop error in sensor units (or sensor units per 100ms for velocity).
        :param timeoutMs:               Timeout value in ms. If nonzero, function will wait for
                                        config success and report an error if it times out.
                                        If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAuxPIDPolarity(self, invert: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the Polarity of the Auxiliary PID (PID1).
        
        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,
        
        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,
        
        :param invert:    If true, use inverted PID1 output polarity.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered
        
        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered
        
        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected
        
        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeakOutput(self, slotIdx: int, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the peak closed-loop output.  This peak output is slot-specific and
        is applied to the output of the associated PID loop.
        This setting is seperate from the generic Peak Output setting.
        
        :param slotIdx:    Parameter slot for the constant.
        :param percentOut: Peak Percent Output from 0 to 1.  This value is absolute and
                           *						the magnitude will apply in both forward and reverse directions.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeriod(self, slotIdx: int, loopTimeMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the loop time (in milliseconds) of the PID closed-loop calculations.
        Default value is 1 ms.
        
        :param slotIdx:    Parameter slot for the constant.
        :param loopTimeMs: Loop timing of the closed-loop calculations.  Minimum value of
                           *						1 ms, maximum of 64 ms.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the closed-loop ramp rate of throttle output.
        
        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                         value of '0' will disable the ramp.
        :param timeoutMs:                Timeout value in ms. If nonzero, function will wait for
                                         config success and report an error if it times out.
                                         If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeout: int) -> ErrorCode:
        """
        Revert all configurations to factory default values.
        Use this before your individual config* calls to avoid having to config every single param.
        
        Alternatively you can use the configAllSettings routine.
        
        :param timeout: Timeout value in ms. Function will generate error if config is
                        not successful within timeout.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFeedbackNotContinuous(self, feedbackNotContinuous: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Disables continuous tracking of the position for analog and pulse-width.
        If the signal goes from 4095 to 0 (pulse-width) a motor controller will continue to read 4096 by default.
        If overflow tracking is disabled, it will wrap to 0 (not continuous)
        
        If using pulse-width on CTRE Mag Encoder (within one rotation) or absolute analog sensor (within one rotation),
        setting feedbackNotContinuous to true is recommended, to prevent intermittent
        connections from causing sensor "jumps" of 4096 (or 1024 for analog) units.
        
        :param feedbackNotContinuous: True to disable the overflow tracking.
        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.
        
        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward soft limit enable.
        
        :param enable:    Forward Sensor Position Limit Enable.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitThreshold(self, forwardSensorLimit: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward soft limit threhold.
        
        :param forwardSensorLimit: Forward Sensor Position Limit (in raw sensor units).
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int:
        """
        Gets the value of a custom parameter.
        
        :param paramIndex: Index of custom parameter [0,1].
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.
        
        :returns: Value of the custom param.
        """
    def configGetParameter(self, paramEnum: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float:
        """
        Gets a parameter.
        
        :param paramEnum: Parameter enumeration.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Value of parameter.
        """
    def configLimitSwitchDisableNeutralOnLOS(self, limitSwitchDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Disables limit switches triggering (if enabled) when the sensor is no longer detected.
        
        :param limitSwitchDisableNeutralOnLOS: disable triggering
        :param timeoutMs:                      Timeout value in ms. If nonzero, function will wait for
                                               config success and report an error if it times out.
                                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMaxIntegralAccumulator(self, slotIdx: int, iaccum: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the maximum integral accumulator in the given parameter slot.
        
        :param slotIdx:   Parameter slot for the constant.
        :param iaccum:    Value of the maximum integral accumulator (closed loop error
                          units X 1ms).
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionAcceleration(self, sensorUnitsPer100msPerSec: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the Motion Magic Acceleration. This is the target acceleration that
        the motion magic curve generator can use.
        
        :param sensorUnitsPer100msPerSec: Motion Magic Acceleration (in raw sensor units per 100 ms per
                                          second).
        :param timeoutMs:                 Timeout value in ms. If nonzero, function will wait for config
                                          success and report an error if it times out. If zero, no
                                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionCruiseVelocity(self, sensorUnitsPer100ms: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the Motion Magic Cruise Velocity. This is the peak target velocity
        that the motion magic curve generator can use.
        
        :param sensorUnitsPer100ms: Motion Magic Cruise Velocity (in raw sensor units per 100 ms).
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for config
                                    success and report an error if it times out. If zero, no
                                    blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryPeriod(self, baseTrajDurationMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        When trajectory points are processed in the motion profile executer, the MPE determines
        how long to apply the active trajectory point by summing baseTrajDurationMs with the
        timeDur of the trajectory point (see TrajectoryPoint).
        
        This allows general selection of the execution rate of the points with 1ms resolution,
        while allowing some degree of change from point to point.
        
        :param baseTrajDurationMs: The base duration time of every trajectory point.
                                   This is summed with the trajectory points unique timeDur.
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionSCurveStrength(self, curveStrength: int, timeoutMs: int) -> ErrorCode:
        """
        Sets the Motion Magic S Curve Strength.
        Call this before using Motion Magic.
        Modifying this during a Motion Magic action should be avoided.
        
        :param curveStrength: 0 to use Trapezoidal Motion Profile. [1,8] for S-Curve (greater value yields greater smoothing).
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for config
                              success and report an error if it times out. If zero, no
                              blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNeutralDeadband(self, percentDeadband: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the output deadband percentage.
        
        :param percentDeadband: Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
                                Pass 0.04 for 4% (factory default).
        :param timeoutMs:       Timeout value in ms. If nonzero, function will wait for
                                config success and report an error if it times out.
                                If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward nominal output percentage.
        
        :param percentOut: Nominal (minimum) percent output. [0,+1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse nominal output percentage.
        
        :param percentOut: Nominal (minimum) percent output. [-1,0]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configOpenloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the open-loop ramp rate of throttle output.
        
        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                         value of '0' will disable the ramp.
        :param timeoutMs:                Timeout value in ms. If nonzero, function will wait for
                                         config success and report an error if it times out.
                                         If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward peak output percentage.
        
        :param percentOut: Desired peak output percentage. [0,1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse peak output percentage.
        
        :param percentOut: Desired peak output percentage.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_EdgesPerRot(self, pulseWidthPeriod_EdgesPerRot: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the edges per rotation of a pulse width sensor. (This should be set for
        tachometer use).
        
        :param pulseWidthPeriod_EdgesPerRot: edges per rotation
        :param timeoutMs:                    Timeout value in ms. If nonzero, function will wait for
                                             config success and report an error if it times out.
                                             If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_FilterWindowSz(self, pulseWidthPeriod_FilterWindowSz: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the number of samples to use in smoothing a pulse width sensor with a rolling
        average. Default is 1 (no smoothing).
        
        :param pulseWidthPeriod_FilterWindowSz: samples for rolling avg
        :param timeoutMs:                       Timeout value in ms. If nonzero, function will wait for
                                                config success and report an error if it times out.
                                                If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, deviceID: int, remoteSensorSource: RemoteSensorSource, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.
        
        :param deviceID:           The device ID of the remote sensor device.
        :param remoteSensorSource: The remote sensor device and signal type to bind.
        :param remoteOrdinal:      0 for configuring Remote Sensor 0,
                                   1 for configuring Remote Sensor 1
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, canCoderRef: sensors.CANCoder, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.
        
        :param canCoderRef:   CANCoder device reference to use.
        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                              1 for configuring Remote Sensor 1
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, talonRef: BaseTalon, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.
        
        :param talonRef:      Talon device reference to use.
        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                              1 for configuring Remote Sensor 1
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configRemoteSensorClosedLoopDisableNeutralOnLOS(self, remoteSensorClosedLoopDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Disables going to neutral (brake/coast) when a remote sensor is no longer detected.
        
        :param remoteSensorClosedLoopDisableNeutralOnLOS: disable going to neutral
        :param timeoutMs:                                 Timeout value in ms. If nonzero, function will wait for
                                                          config success and report an error if it times out.
                                                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.
        
        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse soft limit enable.
        
        :param enable:    Reverse Sensor Position Limit Enable.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitThreshold(self, reverseSensorLimit: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse soft limit threshold.
        
        :param reverseSensorLimit: Reverse Sensor Position Limit (in raw sensor units).
        :param timeoutMs:          Timeout value in ms. If nonzero, function will wait for
                                   config success and report an error if it times out.
                                   If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackCoefficient(self, coefficient: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        The Feedback Coefficient is a scalar applied to the value of the
        feedback sensor.  Useful when you need to scale your sensor values
        within the closed-loop calculations.  Default value is 1.
        
        Selected Feedback Sensor register in firmware is the decoded sensor value
        multiplied by the Feedback Coefficient.
        
        :param coefficient: Feedback Coefficient value.  Maximum value of 1.
                            *						Resolution is 1/(2^16).  Cannot be 0.
        :param pidIdx:      0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.
        
        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: FeedbackDevice, timeoutMs: int = 0) -> ErrorCode:
        """
        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.
        
        :param sensorTerm:     Which sensor term to bind to a feedback source.
        :param feedbackDevice: The sensor signal to attach to sensorTerm.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the value of a custom parameter. This is for arbitrary use.
        
        Sometimes it is necessary to save calibration/limit/target information in
        the device. Particularly if the device is part of a subsystem that can be
        replaced.
        
        :param newValue:   Value for custom parameter.
        :param paramIndex: Index of custom parameter [0,1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets a parameter. Generally this is not used. This can be utilized in -
        Using new features without updating API installation. - Errata
        workarounds to circumvent API implementation. - Allows for rapid testing
        / unit testing of firmware.
        
        :param param:     Parameter enumeration.
        :param value:     Value of parameter.
        :param subValue:  Subvalue for parameter. Maximum value of 255.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSoftLimitDisableNeutralOnLOS(self, softLimitDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode:
        """
        Disables soft limits triggering (if enabled) when the sensor is no longer detected.
        
        :param softLimitDisableNeutralOnLOS: disable triggering
        :param timeoutMs:                    Timeout value in ms. If nonzero, function will wait for
                                             config success and report an error if it times out.
                                             If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageCompSaturation(self, voltage: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the Voltage Compensation saturation voltage.
        
        :param voltage:   This is the max voltage to apply to the hbridge when voltage
                          compensation is enabled.  For example, if 10 (volts) is specified
                          and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
                          then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageMeasurementFilter(self, filterWindowSamples: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the voltage measurement filter.
        
        :param filterWindowSamples: Number of samples in the rolling average of voltage
                                    measurement.
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_IntegralZone(self, slotIdx: int, izone: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the Integral Zone constant in the given parameter slot. If the
        (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.
        
        :param slotIdx:   Parameter slot for the constant.
        :param izone:     Value of the Integral Zone constant (closed loop error units X
                          1ms).
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kD(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the 'D' constant in the given parameter slot.
        
        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)
        
        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the D constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kF(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the 'F' constant in the given parameter slot.
        
        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).
        
        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the F constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kI(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the 'I' constant in the given parameter slot.
        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].
        
        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the I constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kP(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the 'P' constant in the given parameter slot.
        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)
        
        :param slotIdx:   Parameter slot for the constant.
        :param value:     Value of the P constant.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def enableVoltageCompensation(self, enable: bool) -> None:
        """
        Enables voltage compensation. If enabled, voltage compensation works in
        all control modes.
        
        Be sure to configure the saturation voltage before enabling this.
        
        :param enable: Enable state of voltage compensation.
        """
    def getActiveTrajectoryArbFeedFwd(self, pidIdx: int = 0) -> float:
        """
        Gets the active trajectory arbitrary feedforward using
        MotionMagic/MotionProfile control modes.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: The Active Trajectory ArbFeedFwd in units of percent output
                  (where 0.01 is 1%).
        """
    def getActiveTrajectoryPosition(self, pidIdx: int = 0) -> float:
        """
        Gets the active trajectory target position for using
        MotionMagic/MotionProfile control modes.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: The Active Trajectory Position in sensor units.
        """
    def getActiveTrajectoryVelocity(self, pidIdx: int = 0) -> float:
        """
        Gets the active trajectory target velocity for using
        MotionMagic/MotionProfile control modes.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: The Active Trajectory Velocity in sensor units per 100ms.
        """
    def getBaseID(self) -> int:
        """
        :returns: BaseID of device
        """
    def getBusVoltage(self) -> float:
        """
        Gets the bus voltage seen by the device.
        
        :returns: The bus voltage value (in volts).
        """
    def getClosedLoopError(self, pidIdx: int = 0) -> float:
        """
        Gets the closed-loop error. The units depend on which control mode is in
        use.
        
        If closed-loop is seeking a target sensor position, closed-loop error is the difference between target
        and current sensor value (in sensor units.  Example 4096 units per rotation for CTRE Mag Encoder).
        
        If closed-loop is seeking a target sensor velocity, closed-loop error is the difference between target
        and current sensor value (in sensor units per 100ms).
        
        If using motion profiling or Motion Magic, closed loop error is calculated against the current target,
        and not the "final" target at the end of the profile/movement.
        
        See Phoenix-Documentation information on units.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: Closed-loop error value.
        """
    def getClosedLoopTarget(self, pidIdx: int = 0) -> float:
        """
        Gets the current target of a given closed loop.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: The closed loop target.
        """
    def getControlMode(self) -> ControlMode:
        """
        :returns: control mode motor controller is in
        """
    def getDeviceID(self) -> int:
        """
        Returns the Device ID
        
        :returns: Device number.
        """
    def getErrorDerivative(self, pidIdx: int = 0) -> float:
        """
        Gets the derivative of the closed-loop error.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: The error derivative value.
        """
    def getFaults(self, toFill: Faults) -> ErrorCode:
        """
        Polls the various fault flags.
        
        :param toFill: Caller's object to fill with latest fault flags.
        
        :returns: Last Error Code generated by a function.
        """
    def getFirmwareVersion(self) -> int:
        """
        Gets the firmware version of the device.
        
        :returns: Firmware version of device. For example: version 1-dot-2 is
                  0x0102.
        """
    def getIntegralAccumulator(self, pidIdx: int = 0) -> float:
        """
        Gets the iaccum value.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: Integral accumulator value (Closed-loop error X 1ms).
        """
    def getInverted(self) -> bool:
        """
        :returns: invert setting of motor output.
        """
    def getLastError(self) -> ErrorCode:
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.
        
        :returns: Last Error Code generated by a function.
        """
    def getMotionProfileStatus(self, statusToFill: MotionProfileStatus) -> ErrorCode:
        """
        Retrieve all status information.
        For best performance, Caller can snapshot all status information regarding the
        motion profile executer.
        
        The members are filled, as follows...
        
        *	topBufferRem:	The available empty slots in the trajectory buffer.
        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the
        low-level buffer, allowing the motor controller to act on them.
        
        *	topBufferRem: The number of points in the top trajectory buffer.
        
        *	btmBufferCnt: The number of points in the low level controller buffer.
        
        *	hasUnderrun: 	Set if isUnderrun ever gets set.
        Can be manually cleared by clearMotionProfileHasUnderrun() or automatically cleared by startMotionProfile().
        
        *	isUnderrun:		This is set if controller needs to shift a point from its buffer into
        *					the active trajectory point however
        *					the buffer is empty.
        *					This gets cleared automatically when is resolved.
        
        *	activePointValid:	True if the active trajectory point is not empty, false otherwise. The members in activePoint are only valid if this signal is set.
        
        *	isLast:	is set/cleared based on the MP executer's current
        trajectory point's IsLast value.  This assumes
        IsLast was set when PushMotionProfileTrajectory
        was used to insert the currently processed trajectory
        point.
        
        *	profileSlotSelect: The currently processed trajectory point's
        selected slot.  This can differ in the currently selected slot used
        for Position and Velocity servo modes
        
        *	outputEnable:		The current output mode of the motion profile
        *						executer (disabled, enabled, or hold).  When changing the set()
        *						value in MP mode, it's important to check this signal to
        *						confirm the change takes effect before interacting with the top buffer.
        
        :param statusToFill: Caller supplied object to fill.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getMotionProfileTopLevelBufferCount(self) -> int:
        """
        Retrieve just the buffer count for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll the progress of trajectory points being
        emptied into controller's RAM. Otherwise just use GetMotionProfileStatus.
        
        :returns: number of trajectory points in the top buffer.
        """
    def getMotorOutputPercent(self) -> float:
        """
        Gets the output percentage of the motor controller.
        
        :returns: Output of the motor controller (in percent).
        """
    def getMotorOutputVoltage(self) -> float:
        """
        :returns: applied voltage to motor  in volts.
        """
    def getSelectedSensorPosition(self, pidIdx: int = 0) -> float:
        """
        Get the selected sensor position (in raw sensor units).
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop. See
                       Phoenix-Documentation for how to interpret.
        
        :returns: Position of selected sensor (in raw sensor units).
        """
    def getSelectedSensorVelocity(self, pidIdx: int = 0) -> float:
        """
        Get the selected sensor velocity.
        
        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        
        :returns: selected sensor (in raw sensor units) per 100ms.
                  See Phoenix-Documentation for how to interpret.
        """
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: StickyFaults) -> ErrorCode:
        """
        Polls the various sticky fault flags.
        
        :param toFill: Caller's object to fill with latest sticky fault flags.
        
        :returns: Last Error Code generated by a function.
        """
    def getTemperature(self) -> float:
        """
        Gets the temperature of the motor controller.
        
        :returns: Temperature of the motor controller (in 'C)
        """
    def hasResetOccurred(self) -> bool:
        """
        Returns true if the device has reset since last call.
        
        :returns: Has a Device Reset Occurred?
        """
    def isMotionProfileTopLevelBufferFull(self) -> bool:
        """
        Retrieve just the buffer full for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll. Otherwise just use
        GetMotionProfileStatus.
        
        :returns: number of trajectory points in the top buffer.
        """
    def isVoltageCompensationEnabled(self) -> bool:
        """
        Returns the enable state of Voltage Compensation that the caller has set.
        
        :returns: TRUE if voltage compensation is enabled.
        """
    def neutralOutput(self) -> None:
        """
        Neutral the motor output by setting control mode to disabled.
        """
    def overrideLimitSwitchesEnable(self, enable: bool) -> None:
        """
        Sets the enable state for limit switches.
        
        :param enable: Enable state for limit switches.
        """
    def overrideSoftLimitsEnable(self, enable: bool) -> None:
        """
        Can be used to override-disable the soft limits.
        This function can be used to quickly disable soft limits without
        having to modify the persistent configuration.
        
        :param enable: Enable state for soft limit switches.
        """
    def processMotionProfileBuffer(self) -> None:
        """
        This must be called periodically to funnel the trajectory points from the
        API's top level buffer to the controller's bottom level buffer. Recommendation
        is to call this twice as fast as the execution rate of the motion
        profile. So if MP is running with 20ms trajectory points, try calling
        this routine every 10ms. All motion profile functions are thread-safe
        through the use of a mutex, so there is no harm in having the caller
        utilize threading.
        """
    def pushMotionProfileTrajectory(self, trajPt: TrajectoryPoint) -> ErrorCode:
        """
        Push another trajectory point into the top level buffer (which is emptied
        into the motor controller's bottom buffer as room allows).
        
        targPos:  servo position in sensor units.
        *		targVel:  velocity to feed-forward in sensor units
        per 100ms.
        profileSlotSelect0  Which slot to get PIDF gains. PID is used for position servo. F is used
        *						   as the Kv constant for velocity feed-forward. Typically this is hardcoded
        *						   to the a particular slot, but you are free gain schedule if need be.
        *						   Choose from [0,3]
        *		profileSlotSelect1 Which slot to get PIDF gains for auxiliary PId.
        *						   This only has impact during MotionProfileArc Control mode.
        *						   Choose from [0,1].
        isLastPoint  set to nonzero to signal motor controller to keep processing this
        trajectory point, instead of jumping to the next one
        when timeDurMs expires.  Otherwise MP executer will
        eventually see an empty buffer after the last point
        expires, causing it to assert the IsUnderRun flag.
        However this may be desired if calling application
        never wants to terminate the MP.
        *		zeroPos  set to nonzero to signal motor controller to "zero" the selected
        position sensor before executing this trajectory point.
        Typically the first point should have this set only thus
        allowing the remainder of the MP positions to be relative to
        zero.
        *		timeDur Duration to apply this trajectory pt.
        This time unit is ADDED to the exising base time set by
        configMotionProfileTrajectoryPeriod().
        
        :param trajPt: to push into buffer.
                       The members should be filled in with these values...
        
        :returns: CTR_OKAY if trajectory point push ok. ErrorCode if buffer is
                  full due to kMotionProfileTopBufferCapacity.
        """
    def selectProfileSlot(self, slotIdx: int, pidIdx: int) -> ErrorCode:
        """
        Selects which profile slot to use for closed-loop control.
        
        :param slotIdx: Profile slot to select.
        :param pidIdx:  0 for Primary closed-loop. 1 for auxiliary closed-loop.
        """
    @typing.overload
    def set(self, Mode: ControlMode, demand: float) -> None:
        """
        Sets the appropriate output on the talon, depending on the mode.
        
        *	Standard Driving Example:
        *	_talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *	_talonRght.set(ControlMode.PercentOutput, rghtJoy);
        
        :param Mode:   The output mode to apply.
                       In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                       In Current mode, output value is in amperes.
                       In Velocity mode, output value is in position change / 100ms.
                       In Position mode, output value is in encoder ticks or an analog value,
                       depending on the sensor.
                       In Follower mode, the output value is the integer device ID of the talon to
                       duplicate.
        :param demand: The setpoint value, as described above.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        """
        Arcade Drive Example:
        *		_talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);
        
        *	Drive Straight Example:
        *	Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);
        
        *	Drive Straight to a Distance Example:
        *	Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        
        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *	 demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.  Units match the set mode.
        """
    def setControlFramePeriod(self, frame: ControlFrame, periodMs: int) -> ErrorCode:
        """
        Sets the period of the given control frame.
        
        :param frame:    Frame whose period is to be changed.
        :param periodMs: Period in ms for the given frame.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setIntegralAccumulator(self, iaccum: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the integral accumulator. Typically this is used to clear/zero the
        integral accumulator, however some use cases may require seeding the
        accumulator for a faster response.
        
        :param iaccum:    Value to set for the integral accumulator (closed loop error
                          units X 1ms).
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setInverted(self, invert: bool) -> None:
        """
        Inverts the hbridge output of the motor controller.
        
        This does not impact sensor phase and should not be used to correct sensor polarity.
        
        This will invert the hbridge output but NOT the LEDs.
        This ensures....
        - Green LEDs always represents positive request from robot-controller/closed-looping mode.
        - Green LEDs correlates to forward limit switch.
        - Green LEDs correlates to forward soft limit.
        
        :param invert: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None:
        """
        Inverts the hbridge output of the motor controller in relation to the master if present
        
        This does not impact sensor phase and should not be used to correct sensor polarity.
        
        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion
        
        :param invertType: Invert state to set.
        """
    def setNeutralMode(self, neutralMode: NeutralMode) -> None:
        """
        Sets the mode of operation during neutral throttle output.
        
        :param neutralMode: The desired mode of operation when the Controller output
                            throttle is neutral (ie brake/coast)
        """
    def setSelectedSensorPosition(self, sensorPos: float, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode:
        """
        Sets the sensor position to the given value.
        
        :param sensorPos: Position to set for the selected sensor (in raw sensor units).
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setSensorPhase(self, PhaseSensor: bool) -> None:
        """
        Sets the phase of the sensor. Use when controller forward/reverse output
        doesn't correlate to appropriate forward/reverse reading of sensor.
        Pick a value so that positive PercentOutput yields a positive change in sensor.
        After setting this, user can freely call SetInverted() with any value.
        
        :param PhaseSensor: Indicates whether to invert the phase of the sensor.
        """
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period of the given status frame.
        
        User ensure CAN Bus utilization is not high.
        
        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.
        
        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
class IMotorControllerEnhanced(IMotorController):
    """
    Interface for enhanced motor controllers
    """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.
        
        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.
        
        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.
        
        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param deviceID:          Device ID of remote source (Talon SRX or CANifier device ID).
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode:
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.
        
        :param type:              Remote limit switch source. User can choose between a remote
                                  Talon SRX, CANifier, or deactivate the feature.
        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                                  setting matches the Phoenix Tuner drop down.
        :param timeoutMs:         Timeout value in ms. If nonzero, function will wait for config
                                  success and report an error if it times out. If zero, no
                                  blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the feedback device for the motor controller.
        
        :param feedbackDevice: Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the feedback device for the motor controller.
        
        :param feedbackDevice: Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures the supply-side current limit.
        
        :param currLimitCfg: Current limit configuration
        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: VelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period over which velocity measurements are taken.
        
        :param period:    Desired period for the velocity measurement. @see
                          com.ctre.phoenix.motorcontrol.VelocityMeasPeriod
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.
        
        :param windowSize: Number of samples in the rolling average of velocity
                           measurement. Valid values are 1,2,4,8,16,32. If another value
                           is specified, it will truncate to nearest support value.
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getOutputCurrent(self) -> float:
        """
        Gets the output current of the motor controller.
        In the case of TalonSRX class, this routine returns supply current for legacy reasons.  In order to get the "true" output current, call GetStatorCurrent().
        In the case of TalonFX class, this routine returns the true output stator current.
        
        [[deprecated("Use GetStatorCurrent/GetSupplyCurrent instead.")]]
        
        :returns: The output current (in amps).
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period of the given status frame.
        
        User ensure CAN Bus utilization is not high.
        
        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.
        
        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the period of the given status frame.
        
        User ensure CAN Bus utilization is not high.
        
        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.
        
        :param frame:     Frame whose period is to be changed.
        :param periodMs:  Period in ms for the given frame.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
class IOutputSignal:
    """
    Interface for output signals
    """
    def __init__(self) -> None:
        ...
    def set(self, value: float) -> None:
        """
        Set signal
        
        :param value: value to set
        """
class IProcessable:
    """
    Interface for processable objects
    """
    def __init__(self) -> None:
        ...
    def process(self) -> None:
        """
        This function is called when a process occurs
        """
class InvertType:
    """
    Choose the invert type of the motor controller.
    None is the equivalent of SetInverted(false), where positive request yields positive voltage on M+.
    InvertMotorOutput is the equivelant of SetInverted(true), where positive request yields positive voltage on M-.
    FollowMaster/OpposeMaster will match/oppose a master Talon/Victor.  This requires device to be configured as a follower.
    
    Members:
    
      None_ : Same as SetInverted(false)
    
      InvertMotorOutput : Same as SetInverted(true)
    
      FollowMaster : Follow the invert of the master this MC is following.
    
      OpposeMaster : Opposite of the invert of the master this MC is following.
    """
    FollowMaster: typing.ClassVar[InvertType]  # value = <InvertType.FollowMaster: 2>
    InvertMotorOutput: typing.ClassVar[InvertType]  # value = <InvertType.InvertMotorOutput: 1>
    None_: typing.ClassVar[InvertType]  # value = <InvertType.None_: 0>
    OpposeMaster: typing.ClassVar[InvertType]  # value = <InvertType.OpposeMaster: 3>
    __members__: typing.ClassVar[dict[str, InvertType]]  # value = {'None_': <InvertType.None_: 0>, 'InvertMotorOutput': <InvertType.InvertMotorOutput: 1>, 'FollowMaster': <InvertType.FollowMaster: 2>, 'OpposeMaster': <InvertType.OpposeMaster: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class LimitSwitchNormal:
    """
    Choose whether the limit switch is normally
    open or normally closed
    
    Members:
    
      NormallyOpen : Limit Switch is tripped when
    the circuit is closed
    
      NormallyClosed : Limit Switch is tripped when
    the circuit is open
    
      Disabled : Limit switch is disabled
    """
    Disabled: typing.ClassVar[LimitSwitchNormal]  # value = <LimitSwitchNormal.Disabled: 2>
    NormallyClosed: typing.ClassVar[LimitSwitchNormal]  # value = <LimitSwitchNormal.NormallyClosed: 1>
    NormallyOpen: typing.ClassVar[LimitSwitchNormal]  # value = <LimitSwitchNormal.NormallyOpen: 0>
    __members__: typing.ClassVar[dict[str, LimitSwitchNormal]]  # value = {'NormallyOpen': <LimitSwitchNormal.NormallyOpen: 0>, 'NormallyClosed': <LimitSwitchNormal.NormallyClosed: 1>, 'Disabled': <LimitSwitchNormal.Disabled: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class LimitSwitchRoutines:
    """
    Class to handle various functions regarding limit switches
    """
    @staticmethod
    def isRemote(limitSwitchSource: LimitSwitchSource) -> bool:
        """
        Checks if a limit switch is one of the remote values
        (i.e. RemoteTalonSRX or RemoteCANifier)
        
        :param limitSwitchSource: limitSwitchSource to check
        
        :returns: true if it's a remote limit switch source
        """
    @staticmethod
    def promote(limitSwitchSource: RemoteLimitSwitchSource) -> LimitSwitchSource:
        """
        Takes a RemoteLimitSwitchSource and brings it up to a LimitSwitchSource
        
        :param limitSwitchSource: LimitSwitchSource to promote
        
        :returns: promoted limitSwitchSource
        """
class LimitSwitchSource:
    """
    Limit switch source enum
    
    Members:
    
      FeedbackConnector : Limit switch directly connected to motor controller
    
      RemoteTalon : Use Limit switch connected to Talon on CAN
    
      RemoteTalonSRX : Use Limit switch connected to TalonSRX on CAN
    
      RemoteCANifier : User Limit switch connected to CANifier
    
      Deactivated : Don't use a limit switch
    """
    Deactivated: typing.ClassVar[LimitSwitchSource]  # value = <LimitSwitchSource.Deactivated: 3>
    FeedbackConnector: typing.ClassVar[LimitSwitchSource]  # value = <LimitSwitchSource.FeedbackConnector: 0>
    RemoteCANifier: typing.ClassVar[LimitSwitchSource]  # value = <LimitSwitchSource.RemoteCANifier: 2>
    RemoteTalon: typing.ClassVar[LimitSwitchSource]  # value = <LimitSwitchSource.RemoteTalon: 1>
    RemoteTalonSRX: typing.ClassVar[LimitSwitchSource]  # value = <LimitSwitchSource.RemoteTalon: 1>
    __members__: typing.ClassVar[dict[str, LimitSwitchSource]]  # value = {'FeedbackConnector': <LimitSwitchSource.FeedbackConnector: 0>, 'RemoteTalon': <LimitSwitchSource.RemoteTalon: 1>, 'RemoteTalonSRX': <LimitSwitchSource.RemoteTalon: 1>, 'RemoteCANifier': <LimitSwitchSource.RemoteCANifier: 2>, 'Deactivated': <LimitSwitchSource.Deactivated: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class MotionProfileStatus:
    """
    Motion Profile Status
    This is simply a data transer object.
    """
    def __init__(self) -> None:
        ...
    @property
    def activePointValid(self) -> bool:
        """
        True if the active trajectory point is not empty, false otherwise.
        The members in activePoint are only valid if this signal is set.
        """
    @activePointValid.setter
    def activePointValid(self, arg0: bool) -> None:
        ...
    @property
    def btmBufferCnt(self) -> int:
        """
        The number of points in the low level Talon/Victor buffer.
        """
    @btmBufferCnt.setter
    def btmBufferCnt(self, arg0: int) -> None:
        ...
    @property
    def hasUnderrun(self) -> bool:
        """
        Set if isUnderrun ever gets set.
        Can be manually cleared by ClearMotionProfileHasUnderrun() or automatically cleared by StartMotionProfile().
        @see clearMotionProfileHasUnderrun()
        """
    @hasUnderrun.setter
    def hasUnderrun(self, arg0: bool) -> None:
        ...
    @property
    def isLast(self) -> bool:
        """
        True if the active trajectory point is the last point of the profile
        """
    @isLast.setter
    def isLast(self, arg0: bool) -> None:
        ...
    @property
    def isUnderrun(self) -> bool:
        """
        This is set if Talon/Victor needs to shift a point from its buffer into
        the active trajectory point however the buffer is empty. This gets cleared
        automatically when is resolved.
        """
    @isUnderrun.setter
    def isUnderrun(self, arg0: bool) -> None:
        ...
    @property
    def outputEnable(self) -> SetValueMotionProfile:
        """
        The current output mode of the motion profile executer (disabled, enabled, or hold).
        When changing the set() value in MP mode, it's important to check this signal to
        confirm the change takes effect before interacting with the top buffer.
        """
    @outputEnable.setter
    def outputEnable(self, arg0: SetValueMotionProfile) -> None:
        ...
    @property
    def profileSlotSelect0(self) -> int:
        """
        The selected PID[0] profile slot of current profile
        """
    @profileSlotSelect0.setter
    def profileSlotSelect0(self, arg0: int) -> None:
        ...
    @property
    def profileSlotSelect1(self) -> int:
        """
        The selected auxiliary PID[1] profile slot of current profile
        """
    @profileSlotSelect1.setter
    def profileSlotSelect1(self, arg0: int) -> None:
        ...
    @property
    def timeDurMs(self) -> int:
        """
        The applied duration of the active trajectory point
        """
    @timeDurMs.setter
    def timeDurMs(self, arg0: int) -> None:
        ...
    @property
    def topBufferCnt(self) -> int:
        """
        The number of points in the top trajectory buffer.
        """
    @topBufferCnt.setter
    def topBufferCnt(self, arg0: int) -> None:
        ...
    @property
    def topBufferRem(self) -> int:
        """
        The available empty slots in the trajectory buffer.
        
        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the Talon's
        low-level buffer, allowing the Talon to act on them.
        """
    @topBufferRem.setter
    def topBufferRem(self, arg0: int) -> None:
        ...
class MotorCommutation:
    """
    Choose the type of motor commutation.  This is for products that support selectable commutation strategies.
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    
    Members:
    
      Trapezoidal : Trapezoidal Commutation
    """
    Trapezoidal: typing.ClassVar[MotorCommutation]  # value = <MotorCommutation.Trapezoidal: 0>
    __members__: typing.ClassVar[dict[str, MotorCommutation]]  # value = {'Trapezoidal': <MotorCommutation.Trapezoidal: 0>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class MovingAverage:
    """
    Class to calculate the rolling average of a signal
    """
    def __init__(self, capacity: int) -> None:
        """
        Constructor for a MovingAverage Object
        
        :param capacity: maximum number of items this will hold
        """
    def clear(self) -> None:
        """
        Clears all data points
        """
    def getCount(self) -> int:
        """
        :returns: the count of the items
        """
    def getSum(self) -> float:
        """
        :returns: the sum of the items
        """
    def pop(self) -> None:
        """
        Pull out oldest item
        """
    def process(self, input: float) -> float:
        """
        Add input & calculate average
        
        :param input: Value to add
        
        :returns: new average
        """
    def push(self, d: float) -> None:
        """
        Add new item
        
        :param d: item to add
        """
class NeutralMode:
    """
    Choose the neutral mode for a motor controller
    
    Members:
    
      EEPROMSetting : Use the NeutralMode that is set in the MC's persistent storage.
    
      Coast : When commanded to neutral, motor leads are set to high-impedance, allowing mechanism to coast.
    
      Brake : When commanded to neutral, motor leads are commonized electrically to reduce motion.
    """
    Brake: typing.ClassVar[NeutralMode]  # value = <NeutralMode.Brake: 2>
    Coast: typing.ClassVar[NeutralMode]  # value = <NeutralMode.Coast: 1>
    EEPROMSetting: typing.ClassVar[NeutralMode]  # value = <NeutralMode.EEPROMSetting: 0>
    __members__: typing.ClassVar[dict[str, NeutralMode]]  # value = {'EEPROMSetting': <NeutralMode.EEPROMSetting: 0>, 'Coast': <NeutralMode.Coast: 1>, 'Brake': <NeutralMode.Brake: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Orchestra:
    """
    An Orchestra is used to play music through Talon FX motor controllers.
    It uses a "Chirp" (.chrp) music file that can be generated using Phoenix Tuner.
    
    Chirp files are generated from standard MIDI files.
    Each Talon FX can only play a single track within the music file.
    For multi-track files, multiple Talon FXs are needed.
    ie, The first track will be played through the first Talon FX added,
    the second track will be played through the second Talon FX added, etc.
    
    Any Chirp file located in the src/main/deploy directory of your FRC project
    will automatically be copied to the roboRIO on code deploy.
    
    To use the Orchestra:
    - Add the Talon FXs to be used as instruments
    - Load the Chirp file to be played using the LoadMusic routine.
    
    Once ready, the Orchestra can be controlled using standard
    play/pause/stop routines.
    
    New music files can be loaded at any time.
    
    The robot must be enabled to play music.
    
    Calling set on any of the TalonFX instruments while the orchestra is
    playing will pause the orchestra.
    """
    def __init__(self) -> None:
        """
        Constructor for an Orchestra Object.
        Call AddInstrument after this to add the instruments.
        """
    def addInstrument(self, instrument: TalonFX) -> ErrorCode:
        """
        Adds another instrument to the orchestra.
        
        :param instrument: TalonFX to add to orchestra
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearInstruments(self) -> ErrorCode:
        """
        Clears all instruments in the orchestra.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getCurrentTime(self) -> int:
        """
        :returns: The current timestamp of the music file (playing or paused) in milliseconds.
                  The timestamp will reset to zero whenever LoadMusic() or Stop() is called.
                  If IsPlaying() returns false, this routine can be used to determine if music is stopped or paused.
        """
    def isPlaying(self) -> bool:
        """
        Returns whether the current track is actively playing or not
        
        :returns: True if playing, false otherwise
        """
    def loadMusic(self, filePath: str) -> ErrorCode:
        """
        Loads a Chirp file at the specified file path.
        
        If the Chirp file is inside your "src/main/deploy" directory
        this file will be automatically deployed to a default directory in
        the RoboRIO when you deploy code. For these files, the name and file
        extension is sufficient.
        
        Use Tuner to create a Chirp file.
        
        :param filepath: The path to the Chirp File.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def pause(self) -> ErrorCode:
        """
        Pauses the music file that's loaded.
        This saves the current position in the track, so it can be resumed later.
        Pausing while stopped is an invalid request.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def play(self) -> ErrorCode:
        """
        Plays the music file that's loaded.
        If the player is paused, this will resume.
        This will also resume a song if the orchestra was interrupted.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def stop(self) -> ErrorCode:
        """
        Stops the music file that's loaded.
        This resets the current position in the track to the start.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
class ParamEnum:
    """
    Signal enumeration for generic signal access.
    
    Members:
    
      eOnBoot_BrakeMode
    
      eQuadFilterEn
    
      eQuadIdxPolarity
    
      eMotionProfileHasUnderrunErr
    
      eMotionProfileTrajectoryPointDurationMs
    
      eMotionProfileTrajectoryInterpolDis
    
      eStatusFramePeriod
    
      eOpenloopRamp
    
      eClosedloopRamp
    
      eNeutralDeadband
    
      ePeakPosOutput
    
      eNominalPosOutput
    
      ePeakNegOutput
    
      eNominalNegOutput
    
      eProfileParamSlot_P
    
      eProfileParamSlot_I
    
      eProfileParamSlot_D
    
      eProfileParamSlot_F
    
      eProfileParamSlot_IZone
    
      eProfileParamSlot_AllowableErr
    
      eProfileParamSlot_MaxIAccum
    
      eProfileParamSlot_PeakOutput
    
      eClearPositionOnLimitF
    
      eClearPositionOnLimitR
    
      eClearPositionOnQuadIdx
    
      eSampleVelocityPeriod
    
      eSampleVelocityWindow
    
      eFeedbackSensorType
    
      eSelectedSensorPosition
    
      eFeedbackNotContinuous
    
      eRemoteSensorSource
    
      eRemoteSensorDeviceID
    
      eSensorTerm
    
      eRemoteSensorClosedLoopDisableNeutralOnLOS
    
      ePIDLoopPolarity
    
      ePIDLoopPeriod
    
      eSelectedSensorCoefficient
    
      eForwardSoftLimitThreshold
    
      eReverseSoftLimitThreshold
    
      eForwardSoftLimitEnable
    
      eReverseSoftLimitEnable
    
      eNominalBatteryVoltage
    
      eBatteryVoltageFilterSize
    
      eContinuousCurrentLimitAmps
    
      ePeakCurrentLimitMs
    
      ePeakCurrentLimitAmps
    
      eCurrLimit_Amps
    
      eCurrThres_Amps
    
      eCurrEnable
    
      eCurrThres_Ms
    
      eClosedLoopIAccum
    
      eCustomParam
    
      eStickyFaults
    
      eAnalogPosition
    
      eQuadraturePosition
    
      ePulseWidthPosition
    
      eIntegratedSensor
    
      eMotMag_Accel
    
      eMotMag_VelCruise
    
      eMotMag_SCurveLevel
    
      eLimitSwitchSource
    
      eLimitSwitchNormClosedAndDis
    
      eLimitSwitchDisableNeutralOnLOS
    
      eLimitSwitchRemoteDevID
    
      eSoftLimitDisableNeutralOnLOS
    
      ePulseWidthPeriod_EdgesPerRot
    
      ePulseWidthPeriod_FilterWindowSz
    
      eYawOffset
    
      eCompassOffset
    
      eBetaGain
    
      eEnableCompassFusion
    
      eGyroNoMotionCal
    
      eEnterCalibration
    
      eFusedHeadingOffset
    
      eStatusFrameRate
    
      eAccumZ
    
      eTempCompDisable
    
      eMotionMeas_tap_threshX
    
      eMotionMeas_tap_threshY
    
      eMotionMeas_tap_threshZ
    
      eMotionMeas_tap_count
    
      eMotionMeas_tap_time
    
      eMotionMeas_tap_time_multi
    
      eMotionMeas_shake_reject_thresh
    
      eMotionMeas_shake_reject_time
    
      eMotionMeas_shake_reject_timeout
    
      eUnitString
    
      eFeedbackTimeBase
    
      eDefaultConfig
    
      eFastWriteCount
    
      eWriteCount
    
      eReserved1
    
      eMotorCommutation
    
      eSensorInitStrategy
    
      eSensorDirection
    
      eMagnetOffset
    
      eSensorSync
    
      eAbsSensorRange
    
      eChangeCompassUse
    
      eRestartKalman
    
      eAccNoiseAmplificationGain
    
      eMagNoiseAmplificationGain
    
      eGyrNoiseAmplificationGain
    
      eMaxAccKg
    
      eMaxMagKg
    
      eGyroBias
    
      eAccelOffsets
    
      eMagCal
    
      eMagCalSlot
    
      eMagCalRunning
    
      eGyrResolution
    
      eAccelKalmanBiasGain
    
      eMagKalmanBiasGain
    
      eTempCalRunning
    
      eApplyTempCal
    
      eClearTempCal
    
      eDontRunThermComp
    
      eChangeHeatOutput
    
      eSetNoMotionCalDisable
    
      eClearMagCal
    
      eSetGyrSensitivity
    
      eSetVsenseScalar
    
      eConfigMountPoseYaw
    
      eConfigMountPosePitch
    
      eConfigMountPoseRoll
    
      eConfigAccelScalar
    
      eConfigGyroScalarX
    
      eConfigGyroScalarY
    
      eConfigGyroScalarZ
    
      eCustomParam0
    
      eCustomParam1
    
      eLEDStripType
    
      eLossOfSignalBehavior
    
      eBrightnessCoefficient
    
      eStatusLedState
    
      eVBatOutput
    
      eV5Enabled
    """
    __members__: typing.ClassVar[dict[str, ParamEnum]]  # value = {'eOnBoot_BrakeMode': <ParamEnum.eOnBoot_BrakeMode: 31>, 'eQuadFilterEn': <ParamEnum.eQuadFilterEn: 91>, 'eQuadIdxPolarity': <ParamEnum.eQuadIdxPolarity: 108>, 'eMotionProfileHasUnderrunErr': <ParamEnum.eMotionProfileHasUnderrunErr: 119>, 'eMotionProfileTrajectoryPointDurationMs': <ParamEnum.eMotionProfileTrajectoryPointDurationMs: 120>, 'eMotionProfileTrajectoryInterpolDis': <ParamEnum.eMotionProfileTrajectoryInterpolDis: 121>, 'eStatusFramePeriod': <ParamEnum.eStatusFramePeriod: 300>, 'eOpenloopRamp': <ParamEnum.eOpenloopRamp: 301>, 'eClosedloopRamp': <ParamEnum.eClosedloopRamp: 302>, 'eNeutralDeadband': <ParamEnum.eNeutralDeadband: 303>, 'ePeakPosOutput': <ParamEnum.ePeakPosOutput: 305>, 'eNominalPosOutput': <ParamEnum.eNominalPosOutput: 306>, 'ePeakNegOutput': <ParamEnum.ePeakNegOutput: 307>, 'eNominalNegOutput': <ParamEnum.eNominalNegOutput: 308>, 'eProfileParamSlot_P': <ParamEnum.eProfileParamSlot_P: 310>, 'eProfileParamSlot_I': <ParamEnum.eProfileParamSlot_I: 311>, 'eProfileParamSlot_D': <ParamEnum.eProfileParamSlot_D: 312>, 'eProfileParamSlot_F': <ParamEnum.eProfileParamSlot_F: 313>, 'eProfileParamSlot_IZone': <ParamEnum.eProfileParamSlot_IZone: 314>, 'eProfileParamSlot_AllowableErr': <ParamEnum.eProfileParamSlot_AllowableErr: 315>, 'eProfileParamSlot_MaxIAccum': <ParamEnum.eProfileParamSlot_MaxIAccum: 316>, 'eProfileParamSlot_PeakOutput': <ParamEnum.eProfileParamSlot_PeakOutput: 317>, 'eClearPositionOnLimitF': <ParamEnum.eClearPositionOnLimitF: 320>, 'eClearPositionOnLimitR': <ParamEnum.eClearPositionOnLimitR: 321>, 'eClearPositionOnQuadIdx': <ParamEnum.eClearPositionOnQuadIdx: 322>, 'eSampleVelocityPeriod': <ParamEnum.eSampleVelocityPeriod: 325>, 'eSampleVelocityWindow': <ParamEnum.eSampleVelocityWindow: 326>, 'eFeedbackSensorType': <ParamEnum.eFeedbackSensorType: 330>, 'eSelectedSensorPosition': <ParamEnum.eSelectedSensorPosition: 331>, 'eFeedbackNotContinuous': <ParamEnum.eFeedbackNotContinuous: 332>, 'eRemoteSensorSource': <ParamEnum.eRemoteSensorSource: 333>, 'eRemoteSensorDeviceID': <ParamEnum.eRemoteSensorDeviceID: 334>, 'eSensorTerm': <ParamEnum.eSensorTerm: 335>, 'eRemoteSensorClosedLoopDisableNeutralOnLOS': <ParamEnum.eRemoteSensorClosedLoopDisableNeutralOnLOS: 336>, 'ePIDLoopPolarity': <ParamEnum.ePIDLoopPolarity: 337>, 'ePIDLoopPeriod': <ParamEnum.ePIDLoopPeriod: 338>, 'eSelectedSensorCoefficient': <ParamEnum.eSelectedSensorCoefficient: 339>, 'eForwardSoftLimitThreshold': <ParamEnum.eForwardSoftLimitThreshold: 340>, 'eReverseSoftLimitThreshold': <ParamEnum.eReverseSoftLimitThreshold: 341>, 'eForwardSoftLimitEnable': <ParamEnum.eForwardSoftLimitEnable: 342>, 'eReverseSoftLimitEnable': <ParamEnum.eReverseSoftLimitEnable: 343>, 'eNominalBatteryVoltage': <ParamEnum.eNominalBatteryVoltage: 350>, 'eBatteryVoltageFilterSize': <ParamEnum.eBatteryVoltageFilterSize: 351>, 'eContinuousCurrentLimitAmps': <ParamEnum.eContinuousCurrentLimitAmps: 360>, 'ePeakCurrentLimitMs': <ParamEnum.ePeakCurrentLimitMs: 361>, 'ePeakCurrentLimitAmps': <ParamEnum.ePeakCurrentLimitAmps: 362>, 'eCurrLimit_Amps': <ParamEnum.eContinuousCurrentLimitAmps: 360>, 'eCurrThres_Amps': <ParamEnum.ePeakCurrentLimitAmps: 362>, 'eCurrEnable': <ParamEnum.eCurrEnable: 363>, 'eCurrThres_Ms': <ParamEnum.eCurrThres_Ms: 364>, 'eClosedLoopIAccum': <ParamEnum.eClosedLoopIAccum: 370>, 'eCustomParam': <ParamEnum.eCustomParam: 380>, 'eStickyFaults': <ParamEnum.eStickyFaults: 390>, 'eAnalogPosition': <ParamEnum.eAnalogPosition: 400>, 'eQuadraturePosition': <ParamEnum.eQuadraturePosition: 401>, 'ePulseWidthPosition': <ParamEnum.ePulseWidthPosition: 402>, 'eIntegratedSensor': <ParamEnum.eIntegratedSensor: 403>, 'eMotMag_Accel': <ParamEnum.eMotMag_Accel: 410>, 'eMotMag_VelCruise': <ParamEnum.eMotMag_VelCruise: 411>, 'eMotMag_SCurveLevel': <ParamEnum.eMotMag_SCurveLevel: 412>, 'eLimitSwitchSource': <ParamEnum.eLimitSwitchSource: 421>, 'eLimitSwitchNormClosedAndDis': <ParamEnum.eLimitSwitchNormClosedAndDis: 422>, 'eLimitSwitchDisableNeutralOnLOS': <ParamEnum.eLimitSwitchDisableNeutralOnLOS: 423>, 'eLimitSwitchRemoteDevID': <ParamEnum.eLimitSwitchRemoteDevID: 424>, 'eSoftLimitDisableNeutralOnLOS': <ParamEnum.eSoftLimitDisableNeutralOnLOS: 425>, 'ePulseWidthPeriod_EdgesPerRot': <ParamEnum.ePulseWidthPeriod_EdgesPerRot: 430>, 'ePulseWidthPeriod_FilterWindowSz': <ParamEnum.ePulseWidthPeriod_FilterWindowSz: 431>, 'eYawOffset': <ParamEnum.eYawOffset: 160>, 'eCompassOffset': <ParamEnum.eCompassOffset: 161>, 'eBetaGain': <ParamEnum.eBetaGain: 162>, 'eEnableCompassFusion': <ParamEnum.eEnableCompassFusion: 163>, 'eGyroNoMotionCal': <ParamEnum.eGyroNoMotionCal: 164>, 'eEnterCalibration': <ParamEnum.eEnterCalibration: 165>, 'eFusedHeadingOffset': <ParamEnum.eFusedHeadingOffset: 166>, 'eStatusFrameRate': <ParamEnum.eStatusFrameRate: 169>, 'eAccumZ': <ParamEnum.eAccumZ: 170>, 'eTempCompDisable': <ParamEnum.eTempCompDisable: 171>, 'eMotionMeas_tap_threshX': <ParamEnum.eMotionMeas_tap_threshX: 172>, 'eMotionMeas_tap_threshY': <ParamEnum.eMotionMeas_tap_threshY: 173>, 'eMotionMeas_tap_threshZ': <ParamEnum.eMotionMeas_tap_threshZ: 174>, 'eMotionMeas_tap_count': <ParamEnum.eMotionMeas_tap_count: 175>, 'eMotionMeas_tap_time': <ParamEnum.eMotionMeas_tap_time: 176>, 'eMotionMeas_tap_time_multi': <ParamEnum.eMotionMeas_tap_time_multi: 177>, 'eMotionMeas_shake_reject_thresh': <ParamEnum.eMotionMeas_shake_reject_thresh: 178>, 'eMotionMeas_shake_reject_time': <ParamEnum.eMotionMeas_shake_reject_time: 179>, 'eMotionMeas_shake_reject_timeout': <ParamEnum.eMotionMeas_shake_reject_timeout: 180>, 'eUnitString': <ParamEnum.eUnitString: 442>, 'eFeedbackTimeBase': <ParamEnum.eFeedbackTimeBase: 443>, 'eDefaultConfig': <ParamEnum.eDefaultConfig: 500>, 'eFastWriteCount': <ParamEnum.eFastWriteCount: 501>, 'eWriteCount': <ParamEnum.eWriteCount: 502>, 'eReserved1': <ParamEnum.eReserved1: 555>, 'eMotorCommutation': <ParamEnum.eMotorCommutation: 650>, 'eSensorInitStrategy': <ParamEnum.eSensorInitStrategy: 700>, 'eSensorDirection': <ParamEnum.eSensorDirection: 701>, 'eMagnetOffset': <ParamEnum.eMagnetOffset: 702>, 'eSensorSync': <ParamEnum.eSensorSync: 703>, 'eAbsSensorRange': <ParamEnum.eAbsSensorRange: 704>, 'eChangeCompassUse': <ParamEnum.eChangeCompassUse: 800>, 'eRestartKalman': <ParamEnum.eRestartKalman: 801>, 'eAccNoiseAmplificationGain': <ParamEnum.eAccNoiseAmplificationGain: 802>, 'eMagNoiseAmplificationGain': <ParamEnum.eMagNoiseAmplificationGain: 803>, 'eGyrNoiseAmplificationGain': <ParamEnum.eGyrNoiseAmplificationGain: 804>, 'eMaxAccKg': <ParamEnum.eMaxAccKg: 805>, 'eMaxMagKg': <ParamEnum.eMaxMagKg: 806>, 'eGyroBias': <ParamEnum.eGyroBias: 807>, 'eAccelOffsets': <ParamEnum.eAccelOffsets: 808>, 'eMagCal': <ParamEnum.eMagCal: 809>, 'eMagCalSlot': <ParamEnum.eMagCalSlot: 810>, 'eMagCalRunning': <ParamEnum.eMagCalRunning: 811>, 'eGyrResolution': <ParamEnum.eGyrResolution: 812>, 'eAccelKalmanBiasGain': <ParamEnum.eAccelKalmanBiasGain: 813>, 'eMagKalmanBiasGain': <ParamEnum.eMagKalmanBiasGain: 814>, 'eTempCalRunning': <ParamEnum.eTempCalRunning: 815>, 'eApplyTempCal': <ParamEnum.eApplyTempCal: 816>, 'eClearTempCal': <ParamEnum.eClearTempCal: 817>, 'eDontRunThermComp': <ParamEnum.eDontRunThermComp: 818>, 'eChangeHeatOutput': <ParamEnum.eChangeHeatOutput: 819>, 'eSetNoMotionCalDisable': <ParamEnum.eSetNoMotionCalDisable: 820>, 'eClearMagCal': <ParamEnum.eClearMagCal: 821>, 'eSetGyrSensitivity': <ParamEnum.eSetGyrSensitivity: 822>, 'eSetVsenseScalar': <ParamEnum.eSetVsenseScalar: 823>, 'eConfigMountPoseYaw': <ParamEnum.eConfigMountPoseYaw: 824>, 'eConfigMountPosePitch': <ParamEnum.eConfigMountPosePitch: 825>, 'eConfigMountPoseRoll': <ParamEnum.eConfigMountPoseRoll: 826>, 'eConfigAccelScalar': <ParamEnum.eConfigAccelScalar: 827>, 'eConfigGyroScalarX': <ParamEnum.eConfigGyroScalarX: 828>, 'eConfigGyroScalarY': <ParamEnum.eConfigGyroScalarY: 829>, 'eConfigGyroScalarZ': <ParamEnum.eConfigGyroScalarZ: 830>, 'eCustomParam0': <ParamEnum.eCustomParam0: 831>, 'eCustomParam1': <ParamEnum.eCustomParam1: 832>, 'eLEDStripType': <ParamEnum.eLEDStripType: 900>, 'eLossOfSignalBehavior': <ParamEnum.eLossOfSignalBehavior: 901>, 'eBrightnessCoefficient': <ParamEnum.eBrightnessCoefficient: 902>, 'eStatusLedState': <ParamEnum.eStatusLedState: 903>, 'eVBatOutput': <ParamEnum.eVBatOutput: 904>, 'eV5Enabled': <ParamEnum.eV5Enabled: 905>}
    eAbsSensorRange: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eAbsSensorRange: 704>
    eAccNoiseAmplificationGain: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eAccNoiseAmplificationGain: 802>
    eAccelKalmanBiasGain: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eAccelKalmanBiasGain: 813>
    eAccelOffsets: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eAccelOffsets: 808>
    eAccumZ: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eAccumZ: 170>
    eAnalogPosition: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eAnalogPosition: 400>
    eApplyTempCal: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eApplyTempCal: 816>
    eBatteryVoltageFilterSize: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eBatteryVoltageFilterSize: 351>
    eBetaGain: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eBetaGain: 162>
    eBrightnessCoefficient: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eBrightnessCoefficient: 902>
    eChangeCompassUse: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eChangeCompassUse: 800>
    eChangeHeatOutput: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eChangeHeatOutput: 819>
    eClearMagCal: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eClearMagCal: 821>
    eClearPositionOnLimitF: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eClearPositionOnLimitF: 320>
    eClearPositionOnLimitR: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eClearPositionOnLimitR: 321>
    eClearPositionOnQuadIdx: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eClearPositionOnQuadIdx: 322>
    eClearTempCal: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eClearTempCal: 817>
    eClosedLoopIAccum: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eClosedLoopIAccum: 370>
    eClosedloopRamp: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eClosedloopRamp: 302>
    eCompassOffset: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eCompassOffset: 161>
    eConfigAccelScalar: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eConfigAccelScalar: 827>
    eConfigGyroScalarX: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eConfigGyroScalarX: 828>
    eConfigGyroScalarY: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eConfigGyroScalarY: 829>
    eConfigGyroScalarZ: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eConfigGyroScalarZ: 830>
    eConfigMountPosePitch: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eConfigMountPosePitch: 825>
    eConfigMountPoseRoll: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eConfigMountPoseRoll: 826>
    eConfigMountPoseYaw: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eConfigMountPoseYaw: 824>
    eContinuousCurrentLimitAmps: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eContinuousCurrentLimitAmps: 360>
    eCurrEnable: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eCurrEnable: 363>
    eCurrLimit_Amps: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eContinuousCurrentLimitAmps: 360>
    eCurrThres_Amps: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePeakCurrentLimitAmps: 362>
    eCurrThres_Ms: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eCurrThres_Ms: 364>
    eCustomParam: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eCustomParam: 380>
    eCustomParam0: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eCustomParam0: 831>
    eCustomParam1: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eCustomParam1: 832>
    eDefaultConfig: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eDefaultConfig: 500>
    eDontRunThermComp: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eDontRunThermComp: 818>
    eEnableCompassFusion: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eEnableCompassFusion: 163>
    eEnterCalibration: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eEnterCalibration: 165>
    eFastWriteCount: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eFastWriteCount: 501>
    eFeedbackNotContinuous: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eFeedbackNotContinuous: 332>
    eFeedbackSensorType: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eFeedbackSensorType: 330>
    eFeedbackTimeBase: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eFeedbackTimeBase: 443>
    eForwardSoftLimitEnable: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eForwardSoftLimitEnable: 342>
    eForwardSoftLimitThreshold: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eForwardSoftLimitThreshold: 340>
    eFusedHeadingOffset: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eFusedHeadingOffset: 166>
    eGyrNoiseAmplificationGain: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eGyrNoiseAmplificationGain: 804>
    eGyrResolution: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eGyrResolution: 812>
    eGyroBias: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eGyroBias: 807>
    eGyroNoMotionCal: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eGyroNoMotionCal: 164>
    eIntegratedSensor: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eIntegratedSensor: 403>
    eLEDStripType: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eLEDStripType: 900>
    eLimitSwitchDisableNeutralOnLOS: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eLimitSwitchDisableNeutralOnLOS: 423>
    eLimitSwitchNormClosedAndDis: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eLimitSwitchNormClosedAndDis: 422>
    eLimitSwitchRemoteDevID: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eLimitSwitchRemoteDevID: 424>
    eLimitSwitchSource: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eLimitSwitchSource: 421>
    eLossOfSignalBehavior: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eLossOfSignalBehavior: 901>
    eMagCal: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMagCal: 809>
    eMagCalRunning: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMagCalRunning: 811>
    eMagCalSlot: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMagCalSlot: 810>
    eMagKalmanBiasGain: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMagKalmanBiasGain: 814>
    eMagNoiseAmplificationGain: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMagNoiseAmplificationGain: 803>
    eMagnetOffset: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMagnetOffset: 702>
    eMaxAccKg: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMaxAccKg: 805>
    eMaxMagKg: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMaxMagKg: 806>
    eMotMag_Accel: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotMag_Accel: 410>
    eMotMag_SCurveLevel: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotMag_SCurveLevel: 412>
    eMotMag_VelCruise: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotMag_VelCruise: 411>
    eMotionMeas_shake_reject_thresh: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_shake_reject_thresh: 178>
    eMotionMeas_shake_reject_time: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_shake_reject_time: 179>
    eMotionMeas_shake_reject_timeout: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_shake_reject_timeout: 180>
    eMotionMeas_tap_count: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_tap_count: 175>
    eMotionMeas_tap_threshX: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_tap_threshX: 172>
    eMotionMeas_tap_threshY: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_tap_threshY: 173>
    eMotionMeas_tap_threshZ: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_tap_threshZ: 174>
    eMotionMeas_tap_time: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_tap_time: 176>
    eMotionMeas_tap_time_multi: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionMeas_tap_time_multi: 177>
    eMotionProfileHasUnderrunErr: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionProfileHasUnderrunErr: 119>
    eMotionProfileTrajectoryInterpolDis: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionProfileTrajectoryInterpolDis: 121>
    eMotionProfileTrajectoryPointDurationMs: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotionProfileTrajectoryPointDurationMs: 120>
    eMotorCommutation: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eMotorCommutation: 650>
    eNeutralDeadband: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eNeutralDeadband: 303>
    eNominalBatteryVoltage: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eNominalBatteryVoltage: 350>
    eNominalNegOutput: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eNominalNegOutput: 308>
    eNominalPosOutput: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eNominalPosOutput: 306>
    eOnBoot_BrakeMode: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eOnBoot_BrakeMode: 31>
    eOpenloopRamp: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eOpenloopRamp: 301>
    ePIDLoopPeriod: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePIDLoopPeriod: 338>
    ePIDLoopPolarity: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePIDLoopPolarity: 337>
    ePeakCurrentLimitAmps: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePeakCurrentLimitAmps: 362>
    ePeakCurrentLimitMs: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePeakCurrentLimitMs: 361>
    ePeakNegOutput: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePeakNegOutput: 307>
    ePeakPosOutput: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePeakPosOutput: 305>
    eProfileParamSlot_AllowableErr: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eProfileParamSlot_AllowableErr: 315>
    eProfileParamSlot_D: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eProfileParamSlot_D: 312>
    eProfileParamSlot_F: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eProfileParamSlot_F: 313>
    eProfileParamSlot_I: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eProfileParamSlot_I: 311>
    eProfileParamSlot_IZone: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eProfileParamSlot_IZone: 314>
    eProfileParamSlot_MaxIAccum: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eProfileParamSlot_MaxIAccum: 316>
    eProfileParamSlot_P: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eProfileParamSlot_P: 310>
    eProfileParamSlot_PeakOutput: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eProfileParamSlot_PeakOutput: 317>
    ePulseWidthPeriod_EdgesPerRot: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePulseWidthPeriod_EdgesPerRot: 430>
    ePulseWidthPeriod_FilterWindowSz: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePulseWidthPeriod_FilterWindowSz: 431>
    ePulseWidthPosition: typing.ClassVar[ParamEnum]  # value = <ParamEnum.ePulseWidthPosition: 402>
    eQuadFilterEn: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eQuadFilterEn: 91>
    eQuadIdxPolarity: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eQuadIdxPolarity: 108>
    eQuadraturePosition: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eQuadraturePosition: 401>
    eRemoteSensorClosedLoopDisableNeutralOnLOS: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eRemoteSensorClosedLoopDisableNeutralOnLOS: 336>
    eRemoteSensorDeviceID: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eRemoteSensorDeviceID: 334>
    eRemoteSensorSource: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eRemoteSensorSource: 333>
    eReserved1: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eReserved1: 555>
    eRestartKalman: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eRestartKalman: 801>
    eReverseSoftLimitEnable: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eReverseSoftLimitEnable: 343>
    eReverseSoftLimitThreshold: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eReverseSoftLimitThreshold: 341>
    eSampleVelocityPeriod: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSampleVelocityPeriod: 325>
    eSampleVelocityWindow: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSampleVelocityWindow: 326>
    eSelectedSensorCoefficient: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSelectedSensorCoefficient: 339>
    eSelectedSensorPosition: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSelectedSensorPosition: 331>
    eSensorDirection: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSensorDirection: 701>
    eSensorInitStrategy: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSensorInitStrategy: 700>
    eSensorSync: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSensorSync: 703>
    eSensorTerm: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSensorTerm: 335>
    eSetGyrSensitivity: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSetGyrSensitivity: 822>
    eSetNoMotionCalDisable: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSetNoMotionCalDisable: 820>
    eSetVsenseScalar: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSetVsenseScalar: 823>
    eSoftLimitDisableNeutralOnLOS: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eSoftLimitDisableNeutralOnLOS: 425>
    eStatusFramePeriod: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eStatusFramePeriod: 300>
    eStatusFrameRate: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eStatusFrameRate: 169>
    eStatusLedState: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eStatusLedState: 903>
    eStickyFaults: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eStickyFaults: 390>
    eTempCalRunning: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eTempCalRunning: 815>
    eTempCompDisable: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eTempCompDisable: 171>
    eUnitString: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eUnitString: 442>
    eV5Enabled: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eV5Enabled: 905>
    eVBatOutput: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eVBatOutput: 904>
    eWriteCount: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eWriteCount: 502>
    eYawOffset: typing.ClassVar[ParamEnum]  # value = <ParamEnum.eYawOffset: 160>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class RemoteFeedbackDevice:
    """
    Choose the remote feedback device for a motor controller.
    
    Members:
    
      FactoryDefaultOff : [[deprecated("Use None instead.")]]
    Factory default setting for non-enhanced motor controllers
    
      SensorSum : Use Sum0 + Sum1
    
      SensorDifference : Use Diff0 - Diff1
    
      RemoteSensor0 : Use the sensor configured
    in filter0
    
      RemoteSensor1 : Use the sensor configured
    in filter1
    
      None_ : Position and velocity will read 0.
    
      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.
    """
    FactoryDefaultOff: typing.ClassVar[RemoteFeedbackDevice]  # value = <RemoteFeedbackDevice.FactoryDefaultOff: 0>
    None_: typing.ClassVar[RemoteFeedbackDevice]  # value = <RemoteFeedbackDevice.None_: 14>
    RemoteSensor0: typing.ClassVar[RemoteFeedbackDevice]  # value = <RemoteFeedbackDevice.RemoteSensor0: 11>
    RemoteSensor1: typing.ClassVar[RemoteFeedbackDevice]  # value = <RemoteFeedbackDevice.RemoteSensor1: 12>
    SensorDifference: typing.ClassVar[RemoteFeedbackDevice]  # value = <RemoteFeedbackDevice.SensorDifference: 10>
    SensorSum: typing.ClassVar[RemoteFeedbackDevice]  # value = <RemoteFeedbackDevice.SensorSum: 9>
    SoftwareEmulatedSensor: typing.ClassVar[RemoteFeedbackDevice]  # value = <RemoteFeedbackDevice.SoftwareEmulatedSensor: 15>
    __members__: typing.ClassVar[dict[str, RemoteFeedbackDevice]]  # value = {'FactoryDefaultOff': <RemoteFeedbackDevice.FactoryDefaultOff: 0>, 'SensorSum': <RemoteFeedbackDevice.SensorSum: 9>, 'SensorDifference': <RemoteFeedbackDevice.SensorDifference: 10>, 'RemoteSensor0': <RemoteFeedbackDevice.RemoteSensor0: 11>, 'RemoteSensor1': <RemoteFeedbackDevice.RemoteSensor1: 12>, 'None_': <RemoteFeedbackDevice.None_: 14>, 'SoftwareEmulatedSensor': <RemoteFeedbackDevice.SoftwareEmulatedSensor: 15>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class RemoteLimitSwitchSource:
    """
    Remote Limit switch source enum
    
    Members:
    
      FactoryDefaultOff : Don't use limit switch, this is the factory default value
    
      RemoteTalon : Use Limit switch connected to Talon on CAN
    
      RemoteTalonSRX : Use Limit switch connected to TalonSRX on CAN
    
      RemoteCANifier : User Limit switch connected to CANifier
    
      Deactivated : Don't use a limit switch
    """
    Deactivated: typing.ClassVar[RemoteLimitSwitchSource]  # value = <RemoteLimitSwitchSource.Deactivated: 3>
    FactoryDefaultOff: typing.ClassVar[RemoteLimitSwitchSource]  # value = <RemoteLimitSwitchSource.FactoryDefaultOff: 0>
    RemoteCANifier: typing.ClassVar[RemoteLimitSwitchSource]  # value = <RemoteLimitSwitchSource.RemoteCANifier: 2>
    RemoteTalon: typing.ClassVar[RemoteLimitSwitchSource]  # value = <RemoteLimitSwitchSource.RemoteTalon: 1>
    RemoteTalonSRX: typing.ClassVar[RemoteLimitSwitchSource]  # value = <RemoteLimitSwitchSource.RemoteTalon: 1>
    __members__: typing.ClassVar[dict[str, RemoteLimitSwitchSource]]  # value = {'FactoryDefaultOff': <RemoteLimitSwitchSource.FactoryDefaultOff: 0>, 'RemoteTalon': <RemoteLimitSwitchSource.RemoteTalon: 1>, 'RemoteTalonSRX': <RemoteLimitSwitchSource.RemoteTalon: 1>, 'RemoteCANifier': <RemoteLimitSwitchSource.RemoteCANifier: 2>, 'Deactivated': <RemoteLimitSwitchSource.Deactivated: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class RemoteSensorSource:
    """
    Choose the remote sensor source for a motor controller
    
    Members:
    
      Off : Don't use a sensor
    
      TalonSRX_SelectedSensor : Use a sensor connected to
    a TalonSRX and configured on
    the TalonSRX
    
      Pigeon_Yaw : Use a CAN Pigeon's Yaw value
    
      Pigeon_Pitch : Use a CAN Pigeon's Pitch value
    
      Pigeon_Roll : Use a CAN Pigeon's Roll value
    
      CANifier_Quadrature : Use a quadrature sensor
    connected to a CANifier
    
      CANifier_PWMInput0 : Use a PWM sensor connected
    to CANifier's PWM0
    
      CANifier_PWMInput1 : Use a PWM sensor connected
    to CANifier's PWM1
    
      CANifier_PWMInput2 : Use a PWM sensor connected
    to CANifier's PWM2
    
      CANifier_PWMInput3 : Use a PWM sensor connected
    to CANifier's PWM3
    
      GadgeteerPigeon_Yaw : Use the yaw value of a pigeon
    connected to a talon over ribbon cable
    
      GadgeteerPigeon_Pitch : Use the pitch value of a pigeon
    connected to a talon over ribbon cable
    
      GadgeteerPigeon_Roll : Use the roll value of a pigeon
    connected to a talon over ribbon cable
    
      CANCoder : Use CANCoder
    
      TalonFX_SelectedSensor : Use a sensor connected to
    a TalonFX and configured on
    the TalonFX
    """
    CANCoder: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.CANCoder: 13>
    CANifier_PWMInput0: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.CANifier_PWMInput0: 6>
    CANifier_PWMInput1: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.CANifier_PWMInput1: 7>
    CANifier_PWMInput2: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.CANifier_PWMInput2: 8>
    CANifier_PWMInput3: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.CANifier_PWMInput3: 9>
    CANifier_Quadrature: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.CANifier_Quadrature: 5>
    GadgeteerPigeon_Pitch: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.GadgeteerPigeon_Pitch: 11>
    GadgeteerPigeon_Roll: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.GadgeteerPigeon_Roll: 12>
    GadgeteerPigeon_Yaw: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.GadgeteerPigeon_Yaw: 10>
    Off: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.Off: 0>
    Pigeon_Pitch: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.Pigeon_Pitch: 3>
    Pigeon_Roll: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.Pigeon_Roll: 4>
    Pigeon_Yaw: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.Pigeon_Yaw: 2>
    TalonFX_SelectedSensor: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.TalonSRX_SelectedSensor: 1>
    TalonSRX_SelectedSensor: typing.ClassVar[RemoteSensorSource]  # value = <RemoteSensorSource.TalonSRX_SelectedSensor: 1>
    __members__: typing.ClassVar[dict[str, RemoteSensorSource]]  # value = {'Off': <RemoteSensorSource.Off: 0>, 'TalonSRX_SelectedSensor': <RemoteSensorSource.TalonSRX_SelectedSensor: 1>, 'Pigeon_Yaw': <RemoteSensorSource.Pigeon_Yaw: 2>, 'Pigeon_Pitch': <RemoteSensorSource.Pigeon_Pitch: 3>, 'Pigeon_Roll': <RemoteSensorSource.Pigeon_Roll: 4>, 'CANifier_Quadrature': <RemoteSensorSource.CANifier_Quadrature: 5>, 'CANifier_PWMInput0': <RemoteSensorSource.CANifier_PWMInput0: 6>, 'CANifier_PWMInput1': <RemoteSensorSource.CANifier_PWMInput1: 7>, 'CANifier_PWMInput2': <RemoteSensorSource.CANifier_PWMInput2: 8>, 'CANifier_PWMInput3': <RemoteSensorSource.CANifier_PWMInput3: 9>, 'GadgeteerPigeon_Yaw': <RemoteSensorSource.GadgeteerPigeon_Yaw: 10>, 'GadgeteerPigeon_Pitch': <RemoteSensorSource.GadgeteerPigeon_Pitch: 11>, 'GadgeteerPigeon_Roll': <RemoteSensorSource.GadgeteerPigeon_Roll: 12>, 'CANCoder': <RemoteSensorSource.CANCoder: 13>, 'TalonFX_SelectedSensor': <RemoteSensorSource.TalonSRX_SelectedSensor: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SensorCollection:
    """
    Collection of sensors available to a motor controller.
    
    For best performance and update-rate,
    we recommend using the configSelectedFeedbackSensor() and getSelectedSensor*() routines.
    However there are occasions where accessing raw sensor values may be useful or convenient.
    Particularly if you are seeding one sensor based on another, or need to circumvent sensor-phase.
    
    Use the getSensorCollection() routine inside your motor controller to create a sensor collection.
    """
    def __init__(self, motorController: BaseTalon) -> None:
        """
        Constructor for SensorCollection
        
        :param motorController: Talon Motor Controller to connect Collection to
        """
    def getAnalogIn(self) -> int:
        ...
    def getAnalogInRaw(self) -> int:
        ...
    def getAnalogInVel(self) -> int:
        ...
    def getPinStateQuadA(self) -> int:
        ...
    def getPinStateQuadB(self) -> int:
        ...
    def getPinStateQuadIdx(self) -> int:
        ...
    def getPulseWidthPosition(self) -> int:
        ...
    def getPulseWidthRiseToFallUs(self) -> int:
        ...
    def getPulseWidthRiseToRiseUs(self) -> int:
        ...
    def getPulseWidthVelocity(self) -> int:
        ...
    def getQuadraturePosition(self) -> int:
        ...
    def getQuadratureVelocity(self) -> int:
        ...
    def isFwdLimitSwitchClosed(self) -> int:
        ...
    def isRevLimitSwitchClosed(self) -> int:
        ...
    def setAnalogPosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode:
        ...
    def setPulseWidthPosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets pulse width position.
        
        :param newPosition: The position value to apply to the sensor.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.
        
        :returns: an ErrErrorCode
        """
    def setQuadraturePosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode:
        ...
    def syncQuadratureWithPulseWidth(self, bookend0: int, bookend1: int, bCrossZeroOnInterval: bool, offset: int = 0, timeoutMs: int = 0) -> ErrorCode:
        ...
class SensorTerm:
    """
    Choose the sensor term for a motor controller
    
    Members:
    
      Sum0 : Choose Sum0 for a term
    
      Sum1 : Choose Sum1 for a term
    
      Diff0 : Choose Diff0 for a term
    
      Diff1 : Choose Diff1 for a term
    """
    Diff0: typing.ClassVar[SensorTerm]  # value = <SensorTerm.Diff0: 2>
    Diff1: typing.ClassVar[SensorTerm]  # value = <SensorTerm.Diff1: 3>
    Sum0: typing.ClassVar[SensorTerm]  # value = <SensorTerm.Sum0: 0>
    Sum1: typing.ClassVar[SensorTerm]  # value = <SensorTerm.Sum1: 1>
    __members__: typing.ClassVar[dict[str, SensorTerm]]  # value = {'Sum0': <SensorTerm.Sum0: 0>, 'Sum1': <SensorTerm.Sum1: 1>, 'Diff0': <SensorTerm.Diff0: 2>, 'Diff1': <SensorTerm.Diff1: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SetValueMotionProfile:
    """
    Members:
    
      Disable
    
      Enable
    
      Hold
    """
    Disable: typing.ClassVar[SetValueMotionProfile]  # value = <SetValueMotionProfile.Disable: 0>
    Enable: typing.ClassVar[SetValueMotionProfile]  # value = <SetValueMotionProfile.Enable: 1>
    Hold: typing.ClassVar[SetValueMotionProfile]  # value = <SetValueMotionProfile.Hold: 2>
    __members__: typing.ClassVar[dict[str, SetValueMotionProfile]]  # value = {'Disable': <SetValueMotionProfile.Disable: 0>, 'Enable': <SetValueMotionProfile.Enable: 1>, 'Hold': <SetValueMotionProfile.Hold: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SlotConfigUtil:
    """
    Util Class to help with slot configs
    """
    @staticmethod
    def KDDifferent(settings: SlotConfiguration) -> bool:
        ...
    @staticmethod
    def KFDifferent(settings: SlotConfiguration) -> bool:
        ...
    @staticmethod
    def KIDifferent(settings: SlotConfiguration) -> bool:
        ...
    @staticmethod
    def KPDifferent(settings: SlotConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def allowableClosedloopErrorDifferent(settings: SlotConfiguration) -> bool:
        ...
    @staticmethod
    def closedLoopPeakOutputDifferent(settings: SlotConfiguration) -> bool:
        ...
    @staticmethod
    def closedLoopPeriodDifferent(settings: SlotConfiguration) -> bool:
        ...
    @staticmethod
    def integralZoneDifferent(settings: SlotConfiguration) -> bool:
        ...
    @staticmethod
    def maxIntegralAccumulatorDifferent(settings: SlotConfiguration) -> bool:
        ...
    def __init__(self) -> None:
        ...
class SlotConfiguration:
    """
    Configurables available to a slot
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to configs
        
        :returns: String representation of configs
        """
    @property
    def allowableClosedloopError(self) -> float:
        """
        Allowable closed loop error to neutral (in native units)
        """
    @allowableClosedloopError.setter
    def allowableClosedloopError(self, arg0: float) -> None:
        ...
    @property
    def closedLoopPeakOutput(self) -> float:
        """
        Peak output from closed loop [0,1]
        """
    @closedLoopPeakOutput.setter
    def closedLoopPeakOutput(self, arg0: float) -> None:
        ...
    @property
    def closedLoopPeriod(self) -> int:
        """
        Desired period of closed loop [1,64]ms
        """
    @closedLoopPeriod.setter
    def closedLoopPeriod(self, arg0: int) -> None:
        ...
    @property
    def integralZone(self) -> float:
        """
        Integral zone (in native units)
        
        If the (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.
        """
    @integralZone.setter
    def integralZone(self, arg0: float) -> None:
        ...
    @property
    def kD(self) -> float:
        """
        D Gain
        
        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)
        """
    @kD.setter
    def kD(self, arg0: float) -> None:
        ...
    @property
    def kF(self) -> float:
        """
        F Gain
        
        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).
        """
    @kF.setter
    def kF(self, arg0: float) -> None:
        ...
    @property
    def kI(self) -> float:
        """
        I Gain
        
        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].
        """
    @kI.setter
    def kI(self, arg0: float) -> None:
        ...
    @property
    def kP(self) -> float:
        """
        P Gain
        
        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)
        """
    @kP.setter
    def kP(self, arg0: float) -> None:
        ...
    @property
    def maxIntegralAccumulator(self) -> float:
        """
        Max integral accumulator (in native units)
        """
    @maxIntegralAccumulator.setter
    def maxIntegralAccumulator(self, arg0: float) -> None:
        ...
class StatorCurrentLimitConfiguration:
    """
    Describes the desired stator current limiting behavior.
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    """
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, rhs: StatorCurrentLimitConfiguration) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        """
        Default c'tor.  Because currentLimit is zero, limiting id disabled.
        """
    @typing.overload
    def __init__(self, enable: bool, currentLimit: float, triggerThresholdCurrent: float, triggerThresholdTime: float) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: string representation of current faults tripped
        """
    def toArray(self) -> list[float]:
        ...
    @property
    def currentLimit(self) -> float:
        """
        The "holding" current (amperes) to limit to when feature is activated.
        """
    @currentLimit.setter
    def currentLimit(self, arg0: float) -> None:
        ...
    @property
    def enable(self) -> bool:
        """
        True/False to enable/disable limit feature.
        """
    @enable.setter
    def enable(self, arg0: bool) -> None:
        ...
    @property
    def triggerThresholdCurrent(self) -> float:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.
        """
    @triggerThresholdCurrent.setter
    def triggerThresholdCurrent(self, arg0: float) -> None:
        ...
    @property
    def triggerThresholdTime(self) -> float:
        """
        How long current must exceed threshold (seconds) before limiting occurs.
        """
    @triggerThresholdTime.setter
    def triggerThresholdTime(self, arg0: float) -> None:
        ...
class StatusFrame:
    """
    The different status frames available to motor controllers
    
    Members:
    
      Status_1_General_ : General Status
    
      Status_2_Feedback0_ : Main controller feedback
    
      Status_4_AinTempVbat_ : Analog sensor, motor controller
    temperature, and voltage at input leads
    
      Status_6_Misc_ : Miscellaneous signals
    
      Status_7_CommStatus_ : Communication status to controller
    
      Status_9_MotProfBuffer_ : Motion profile buffer status
    
      Status_10_MotionMagic_ : Old name for Status 10.
    Use @see #Status_10_Targets instead.
    
      Status_10_Targets_ : Correct name for Status 10.
    Functionally equivalent to @see #Status_10_MotionMagic
    
      Status_12_Feedback1_ : Secondary controller feedback
    
      Status_13_Base_PIDF0_ : Base PID
    
      Status_14_Turn_PIDF1_ : Auxiliary PID
    
      Status_15_FirmwareApiStatus_ : Firmware & API status information
    
      Status_15_FirmareApiStatus_ : Firmware & API status information
    [[deprecated("Use Status_15_FirmwareApiStatus\_ instead.")]]
    
      Status_17_Targets1_ : MotionProfile Targets for Auxiliary PID1.
    """
    Status_10_MotionMagic_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_10_MotionMagic_: 5696>
    Status_10_Targets_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_10_MotionMagic_: 5696>
    Status_12_Feedback1_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_12_Feedback1_: 5824>
    Status_13_Base_PIDF0_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_13_Base_PIDF0_: 5888>
    Status_14_Turn_PIDF1_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_14_Turn_PIDF1_: 5952>
    Status_15_FirmareApiStatus_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_15_FirmwareApiStatus_: 6016>
    Status_15_FirmwareApiStatus_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_15_FirmwareApiStatus_: 6016>
    Status_17_Targets1_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_17_Targets1_: 7168>
    Status_1_General_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_1_General_: 5120>
    Status_2_Feedback0_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_2_Feedback0_: 5184>
    Status_4_AinTempVbat_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_4_AinTempVbat_: 5312>
    Status_6_Misc_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_6_Misc_: 5440>
    Status_7_CommStatus_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_7_CommStatus_: 5504>
    Status_9_MotProfBuffer_: typing.ClassVar[StatusFrame]  # value = <StatusFrame.Status_9_MotProfBuffer_: 5632>
    __members__: typing.ClassVar[dict[str, StatusFrame]]  # value = {'Status_1_General_': <StatusFrame.Status_1_General_: 5120>, 'Status_2_Feedback0_': <StatusFrame.Status_2_Feedback0_: 5184>, 'Status_4_AinTempVbat_': <StatusFrame.Status_4_AinTempVbat_: 5312>, 'Status_6_Misc_': <StatusFrame.Status_6_Misc_: 5440>, 'Status_7_CommStatus_': <StatusFrame.Status_7_CommStatus_: 5504>, 'Status_9_MotProfBuffer_': <StatusFrame.Status_9_MotProfBuffer_: 5632>, 'Status_10_MotionMagic_': <StatusFrame.Status_10_MotionMagic_: 5696>, 'Status_10_Targets_': <StatusFrame.Status_10_MotionMagic_: 5696>, 'Status_12_Feedback1_': <StatusFrame.Status_12_Feedback1_: 5824>, 'Status_13_Base_PIDF0_': <StatusFrame.Status_13_Base_PIDF0_: 5888>, 'Status_14_Turn_PIDF1_': <StatusFrame.Status_14_Turn_PIDF1_: 5952>, 'Status_15_FirmwareApiStatus_': <StatusFrame.Status_15_FirmwareApiStatus_: 6016>, 'Status_15_FirmareApiStatus_': <StatusFrame.Status_15_FirmwareApiStatus_: 6016>, 'Status_17_Targets1_': <StatusFrame.Status_17_Targets1_: 7168>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class StatusFrameEnhanced:
    """
    The different status frames available to enhanced motor controllers
    
    Members:
    
      Status_1_General : General Status
    
      Status_2_Feedback0 : Feedback for selected sensor on primary PID[0].
    
      Status_4_AinTempVbat : Analog sensor, motor controller
    temperature, and voltage at input leads
    
      Status_6_Misc : Miscellaneous signals
    
      Status_7_CommStatus : Communication status
    
      Status_9_MotProfBuffer : Motion profile buffer status
    
      Status_10_MotionMagic : Old name for Status 10.
    Use @see #Status_10_Targets instead.
    
      Status_10_Targets : Correct name for Status 10.
    Functionally equivalent to @see #Status_10_MotionMagic
    
      Status_12_Feedback1 : Feedback for selected sensor on aux PID[1].
    
      Status_13_Base_PIDF0 : Primary PID
    
      Status_14_Turn_PIDF1 : Auxiliary PID
    
      Status_15_FirmwareApiStatus : Firmware & API status information
    
      Status_15_FirmareApiStatus : Firmware & API status information
    [[deprecated("Use Status_15_FirmwareApiStatus instead.")]]
    
      Status_17_Targets1 : MotionProfile Targets for Auxiliary PID1.
    
      Status_3_Quadrature : Quadrature sensor
    
      Status_8_PulseWidth : Pulse width sensor
    
      Status_11_UartGadgeteer : Gadgeteer status
    
      Status_Brushless_Current : Brushless Current Status.
    Includes Stator and Supply Current for Talon FX.
    
      Status_21_FeedbackIntegrated : FX Integrated sensor
    """
    Status_10_MotionMagic: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_10_MotionMagic: 5696>
    Status_10_Targets: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_10_MotionMagic: 5696>
    Status_11_UartGadgeteer: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_11_UartGadgeteer: 5760>
    Status_12_Feedback1: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_12_Feedback1: 5824>
    Status_13_Base_PIDF0: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_13_Base_PIDF0: 5888>
    Status_14_Turn_PIDF1: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_14_Turn_PIDF1: 5952>
    Status_15_FirmareApiStatus: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_15_FirmwareApiStatus: 6016>
    Status_15_FirmwareApiStatus: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_15_FirmwareApiStatus: 6016>
    Status_17_Targets1: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_17_Targets1: 7168>
    Status_1_General: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_1_General: 5120>
    Status_21_FeedbackIntegrated: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_21_FeedbackIntegrated: 9472>
    Status_2_Feedback0: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_2_Feedback0: 5184>
    Status_3_Quadrature: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_3_Quadrature: 5248>
    Status_4_AinTempVbat: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_4_AinTempVbat: 5312>
    Status_6_Misc: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_6_Misc: 5440>
    Status_7_CommStatus: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_7_CommStatus: 5504>
    Status_8_PulseWidth: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_8_PulseWidth: 5568>
    Status_9_MotProfBuffer: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_9_MotProfBuffer: 5632>
    Status_Brushless_Current: typing.ClassVar[StatusFrameEnhanced]  # value = <StatusFrameEnhanced.Status_Brushless_Current: 4672>
    __members__: typing.ClassVar[dict[str, StatusFrameEnhanced]]  # value = {'Status_1_General': <StatusFrameEnhanced.Status_1_General: 5120>, 'Status_2_Feedback0': <StatusFrameEnhanced.Status_2_Feedback0: 5184>, 'Status_4_AinTempVbat': <StatusFrameEnhanced.Status_4_AinTempVbat: 5312>, 'Status_6_Misc': <StatusFrameEnhanced.Status_6_Misc: 5440>, 'Status_7_CommStatus': <StatusFrameEnhanced.Status_7_CommStatus: 5504>, 'Status_9_MotProfBuffer': <StatusFrameEnhanced.Status_9_MotProfBuffer: 5632>, 'Status_10_MotionMagic': <StatusFrameEnhanced.Status_10_MotionMagic: 5696>, 'Status_10_Targets': <StatusFrameEnhanced.Status_10_MotionMagic: 5696>, 'Status_12_Feedback1': <StatusFrameEnhanced.Status_12_Feedback1: 5824>, 'Status_13_Base_PIDF0': <StatusFrameEnhanced.Status_13_Base_PIDF0: 5888>, 'Status_14_Turn_PIDF1': <StatusFrameEnhanced.Status_14_Turn_PIDF1: 5952>, 'Status_15_FirmwareApiStatus': <StatusFrameEnhanced.Status_15_FirmwareApiStatus: 6016>, 'Status_15_FirmareApiStatus': <StatusFrameEnhanced.Status_15_FirmwareApiStatus: 6016>, 'Status_17_Targets1': <StatusFrameEnhanced.Status_17_Targets1: 7168>, 'Status_3_Quadrature': <StatusFrameEnhanced.Status_3_Quadrature: 5248>, 'Status_8_PulseWidth': <StatusFrameEnhanced.Status_8_PulseWidth: 5568>, 'Status_11_UartGadgeteer': <StatusFrameEnhanced.Status_11_UartGadgeteer: 5760>, 'Status_Brushless_Current': <StatusFrameEnhanced.Status_Brushless_Current: 4672>, 'Status_21_FeedbackIntegrated': <StatusFrameEnhanced.Status_21_FeedbackIntegrated: 9472>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class StatusFrameRoutines:
    """
    Class to allow conversion from StatusFrame to EnhancedStatusFrame
    """
    def promote(self, statusFrame: StatusFrame) -> StatusFrameEnhanced:
        """
        Converts a status frame to an enhanced status frame
        
        :param statusFrame: frame to convert
        
        :returns: enhanced status frame version of statusFrame
        """
class StickyFaults:
    """
    All the sticky faults available to motor controllers
    """
    @typing.overload
    def __init__(self, bits: int) -> None:
        """
        Creates fault list with specified bit field of faults
        
        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: string representation of current faults tripped
        """
    def hasAnyFault(self) -> bool:
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int:
        """
        :returns: Current fault list as a bit field
        """
    @property
    def APIError(self) -> bool:
        """
        Device detects an API error
        """
    @APIError.setter
    def APIError(self, arg0: bool) -> None:
        ...
    @property
    def ForwardLimitSwitch(self) -> bool:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited
        """
    @ForwardLimitSwitch.setter
    def ForwardLimitSwitch(self, arg0: bool) -> None:
        ...
    @property
    def ForwardSoftLimit(self) -> bool:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited
        """
    @ForwardSoftLimit.setter
    def ForwardSoftLimit(self, arg0: bool) -> None:
        ...
    @property
    def HardwareESDReset(self) -> bool:
        """
        Not used, @see #ResetDuringEn
        """
    @HardwareESDReset.setter
    def HardwareESDReset(self, arg0: bool) -> None:
        ...
    @property
    def RemoteLossOfSignal(self) -> bool:
        """
        Remote Sensor is no longer detected on bus
        """
    @RemoteLossOfSignal.setter
    def RemoteLossOfSignal(self, arg0: bool) -> None:
        ...
    @property
    def ResetDuringEn(self) -> bool:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.
        """
    @ResetDuringEn.setter
    def ResetDuringEn(self, arg0: bool) -> None:
        ...
    @property
    def ReverseLimitSwitch(self) -> bool:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited
        """
    @ReverseLimitSwitch.setter
    def ReverseLimitSwitch(self, arg0: bool) -> None:
        ...
    @property
    def ReverseSoftLimit(self) -> bool:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited
        """
    @ReverseSoftLimit.setter
    def ReverseSoftLimit(self, arg0: bool) -> None:
        ...
    @property
    def SensorOutOfPhase(self) -> bool:
        """
        Device detects its sensor is out of phase
        """
    @SensorOutOfPhase.setter
    def SensorOutOfPhase(self, arg0: bool) -> None:
        ...
    @property
    def SensorOverflow(self) -> bool:
        """
        Device's sensor overflowed
        """
    @SensorOverflow.setter
    def SensorOverflow(self, arg0: bool) -> None:
        ...
    @property
    def SupplyOverV(self) -> bool:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.
        """
    @SupplyOverV.setter
    def SupplyOverV(self, arg0: bool) -> None:
        ...
    @property
    def SupplyUnstable(self) -> bool:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.
        """
    @SupplyUnstable.setter
    def SupplyUnstable(self, arg0: bool) -> None:
        ...
    @property
    def UnderVoltage(self) -> bool:
        """
        Motor Controller is under 6.5V
        """
    @UnderVoltage.setter
    def UnderVoltage(self, arg0: bool) -> None:
        ...
class SupplyCurrentLimitConfiguration:
    """
    Describes the desired stator current limiting behavior.
    """
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, rhs: SupplyCurrentLimitConfiguration) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        """
        Default c'tor.  Because currentLimit is zero, limiting is disabled.
        """
    @typing.overload
    def __init__(self, enable: bool, currentLimit: float, triggerThresholdCurrent: float, triggerThresholdTime: float) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: string representation of current faults tripped
        """
    def toArray(self) -> list[float]:
        ...
    @property
    def currentLimit(self) -> float:
        """
        The "holding" current (amperes) to limit to when feature is activated.
        """
    @currentLimit.setter
    def currentLimit(self, arg0: float) -> None:
        ...
    @property
    def enable(self) -> bool:
        """
        True/False to enable/disable limit feature.
        """
    @enable.setter
    def enable(self, arg0: bool) -> None:
        ...
    @property
    def triggerThresholdCurrent(self) -> float:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.
        """
    @triggerThresholdCurrent.setter
    def triggerThresholdCurrent(self, arg0: float) -> None:
        ...
    @property
    def triggerThresholdTime(self) -> float:
        """
        How long current must exceed threshold (seconds) before limiting occurs.
        """
    @triggerThresholdTime.setter
    def triggerThresholdTime(self, arg0: float) -> None:
        ...
class TalonFX(BaseTalon):
    """
    CTRE Talon FX Motor Controller when used on CAN Bus.
    
    ::
    
      {@code
      // Example usage of a TalonFX motor controller
      TalonFX motor{0}; // creates a new TalonFX with ID 0
      
      TalonFXConfiguration config;
      config.supplyCurrLimit.enable = true;
      config.supplyCurrLimit.triggerThresholdCurrent = 40; // the peak supply current, in amps
      config.supplyCurrLimit.triggerThresholdTime = 1.5; // the time at the peak supply current before the limit triggers, in sec
      config.supplyCurrLimit.currentLimit = 30; // the current to maintain if the peak supply limit is triggered
      motor.ConfigAllSettings(config); // apply the config settings; this selects the quadrature encoder
      
      motor.Set(TalonFXControlMode::PercentOutput, 0.5); // runs the motor at 50% power
      
      std::cout << motor.GetSelectedSensorPosition() << std::endl; // prints the position of the selected sensor
      std::cout << motor.GetSelectedSensorVelocity() << std::endl; // prints the velocity recorded by the selected sensor
      std::cout << motor.GetMotorOutputPercent() << std::endl; // prints the percent output of the motor (0.5)
      std::cout << motor.GetStatorCurrent() << std::endl; // prints the output current of the motor
      
      ErrorCode error = motor.GetLastError(); // gets the last error generated by the motor controller
      Faults faults;
      ErrorCode faultsError = motor.GetFaults(faults); // fills faults with the current motor controller faults; returns the last error generated
      
      motor.SetStatusFramePeriod(StatusFrameEnhanced::Status_2_Feedback0, 10); // changes the period of the Status 2 frame (GetSelectedSensor*()) to 10ms
      }
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    
    .. seealso::
       :class:`WPI_TalonFX`
    """
    def __init__(self, deviceNumber: int, canbus: str = '') -> None:
        """
        Constructor for a Talon
        
        :param deviceNumber: CAN Device ID of TalonFX
        :param canbus:       Name of the CANbus; can be a SocketCAN interface (on Linux),
                             or a CANivore device name or serial number
        """
    def configAllSettings(self, allConfigs: TalonFXConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures all persistent settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetMotorCommutation(self, motorCommutation: MotorCommutation, timeoutMs: int = 0) -> ErrorCode:
        """
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out.
        
        :returns: The motor commutation type.
        """
    def configGetStatorCurrentLimit(self, currLimitConfigsToFill: StatorCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Gets the stator (output) current limit configuration.
        
        :param currLimitConfigsToFill: Configuration object to fill with read values.
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetSupplyCurrentLimit(self, currLimitConfigsToFill: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Gets the supply current limit configuration.
        
        :param currLimitConfigsToFill: Configuration object to fill with read values.
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorAbsoluteRange(self, absoluteSensorRange: sensors.AbsoluteSensorRange, timeoutMs: int = 0) -> ErrorCode:
        """
        Sets the signage and range of the "Absolute Position" signal.
        Choose unsigned for an absolute range of [0,+1) rotations, [0,360) deg, etc...
        Choose signed for an absolute range of [-0.5,+0.5) rotations, [-180,+180) deg, etc...
        
        :param absoluteSensorRange: Desired Sign/Range for the absolute position register.
        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorInitializationStrategy(self, initializationStrategy: sensors.SensorInitializationStrategy, timeoutMs: int = 0) -> ErrorCode:
        """
        Pick the strategy on how to initialize the integrated sensor absolute position register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position (swerve for example).
        Or it may be desired to zero the sensor on boot (drivetrain translation sensor or a relative servo).
        
        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the product is reset.
        
        :param initializationStrategy: The sensor initialization strategy to use.  This will impact the behavior the next time product boots up.
        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorOffset(self, offsetDegrees: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.
        
        :param offsetDegrees: Offset in degrees (unit string and coefficient DO NOT apply for this config).
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotorCommutation(self, motorCommutation: MotorCommutation, timeoutMs: int = 0) -> ErrorCode:
        """
        Configure the motor commutation type.
        
        :param motorCommutation: Motor Commutation Type.
        :param timeoutMs:        Timeout value in ms. If nonzero, function will wait for config
                                 success and report an error if it times out. If zero, no
                                 blocking or checking is performed.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: TalonFXFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the feedback device for the motor controller.
        
        :param feedbackDevice: Talon FX Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        ...
    def configStatorCurrentLimit(self, currLimitConfigs: StatorCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures the stator (output) current limit.
        
        :param currLimitCfg: Current limit configuration
        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures the supply-side current limit.
        
        :param currLimitCfg: Current limit configuration
        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configurePID(self, pid: TalonFXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode:
        """
        Sets all PID persistant settings.
        
        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getAllConfigs(self, allConfigs: TalonFXConfiguration, timeoutMs: int = 50) -> None:
        """
        Gets all persistant settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: TalonFXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None:
        """
        Gets all PID set persistant settings.
        
        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getSensorCollection(self) -> TalonFXSensorCollection:
        """
        :returns: object that can get/set individual RAW sensor values.
        """
    def getSimCollection(self) -> TalonFXSimCollection:
        """
        :returns: object that can set simulation inputs.
        """
    @typing.overload
    def set(self, mode: TalonFXControlMode, value: float) -> None:
        """
        Sets the appropriate output on the talon, depending on the mode.
        
        *	Standard Driving Example:
        *	_talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *	_talonRght.set(ControlMode.PercentOutput, rghtJoy);
        
        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Current mode, output value is in amperes.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the talon to
                      duplicate.
        :param value: The setpoint value, as described above.
        """
    @typing.overload
    def set(self, mode: TalonFXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        """
        Arcade Drive Example:
        *		_talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);
        
        *	Drive Straight Example:
        *	Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);
        
        *	Drive Straight to a Distance Example:
        *	Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        
        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                            PID is always executed as standard Position PID control.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *	 demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.
                            AuxPID: Target position in Sensor Units
                            ArbitraryFeedForward: Percent Output between -1.0 and 1.0
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
    @typing.overload
    def setInverted(self, invertType: TalonFXInvertType) -> None:
        """
        Inverts the hbridge output of the motor controller in relation to the master if present
        
        This does not impact sensor phase and should not be used to correct sensor polarity.
        
        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion
        
        :param invertType: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None:
        ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None:
        ...
class TalonFXConfigUtil:
    """
    Util class to help with talon configs
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    """
    @staticmethod
    def absoluteSensorRangeDifferent(settings: TalonFXConfiguration) -> bool:
        ...
    @staticmethod
    def initializationStrategyDifferent(settings: TalonFXConfiguration) -> bool:
        ...
    @staticmethod
    def integratedSensorOffsetDegreesDifferent(settings: TalonFXConfiguration) -> bool:
        ...
    @staticmethod
    def motorCommutationDifferent(settings: TalonFXConfiguration) -> bool:
        ...
    @staticmethod
    def statorCurrentDurationDifferent(settings: TalonFXConfiguration) -> bool:
        ...
    @staticmethod
    def supplyCurrentLimitDifferent(settings: TalonFXConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    def __init__(self) -> None:
        ...
class TalonFXConfiguration(BaseTalonConfiguration):
    """
    Configurables available to TalonFX
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to all the configs
        
        :returns: String representation of all the configs
        """
    @property
    def absoluteSensorRange(self) -> sensors.AbsoluteSensorRange:
        """
        Desired Sign / Range for the absolute position register.
        Choose unsigned for an absolute range of[0, +1) rotations, [0, 360) deg, etc.
        Choose signed for an absolute range of[-0.5, +0.5) rotations, [-180, +180) deg, etc.
        """
    @absoluteSensorRange.setter
    def absoluteSensorRange(self, arg0: sensors.AbsoluteSensorRange) -> None:
        ...
    @property
    def initializationStrategy(self) -> sensors.SensorInitializationStrategy:
        """
        The sensor initialization strategy to use.This will impact the behavior the next time device boots up.
        
        Pick the strategy on how to initialize the "Position" register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position(swerve for example).
        Or it may be desired to zero the sensor on boot(drivetrain translation sensor or a relative servo).
        
        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the device is reset.
        """
    @initializationStrategy.setter
    def initializationStrategy(self, arg0: sensors.SensorInitializationStrategy) -> None:
        ...
    @property
    def integratedSensorOffsetDegrees(self) -> float:
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.
        """
    @integratedSensorOffsetDegrees.setter
    def integratedSensorOffsetDegrees(self, arg0: float) -> None:
        ...
    @property
    def motorCommutation(self) -> MotorCommutation:
        """
        Choose the type of motor commutation.
        """
    @motorCommutation.setter
    def motorCommutation(self, arg0: MotorCommutation) -> None:
        ...
    @property
    def statorCurrLimit(self) -> StatorCurrentLimitConfiguration:
        """
        Stator-side current limiting.  This is typically used to limit acceleration/torque and heat generation.
        """
    @statorCurrLimit.setter
    def statorCurrLimit(self, arg0: StatorCurrentLimitConfiguration) -> None:
        ...
    @property
    def supplyCurrLimit(self) -> SupplyCurrentLimitConfiguration:
        """
        Supply-side current limiting.  This is typically used to prevent breakers from tripping.
        """
    @supplyCurrLimit.setter
    def supplyCurrLimit(self, arg0: SupplyCurrentLimitConfiguration) -> None:
        ...
class TalonFXControlMode:
    """
    Choose the control mode for a TalonFX / Falcon 500.
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    
    Members:
    
      PercentOutput : Percent output [-1,1]
    
      Position : Position closed loop
    
      Velocity : Velocity closed loop
    
      Current : Input current closed loop
    
      Follower : Follow other motor controller
    
      MotionProfile : Motion Profile
    
      MotionMagic : Motion Magic
    
      MotionProfileArc : Motion Profile with auxiliary output
    
      MusicTone : Plays a single tone.  Frequency (hz) is passed into set.
    
      Disabled : Disable Motor Controller
    """
    Current: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.Current: 3>
    Disabled: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.Disabled: 15>
    Follower: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.Follower: 5>
    MotionMagic: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.MotionMagic: 7>
    MotionProfile: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.MotionProfile: 6>
    MotionProfileArc: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.MotionProfileArc: 10>
    MusicTone: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.MusicTone: 13>
    PercentOutput: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.PercentOutput: 0>
    Position: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.Position: 1>
    Velocity: typing.ClassVar[TalonFXControlMode]  # value = <TalonFXControlMode.Velocity: 2>
    __members__: typing.ClassVar[dict[str, TalonFXControlMode]]  # value = {'PercentOutput': <TalonFXControlMode.PercentOutput: 0>, 'Position': <TalonFXControlMode.Position: 1>, 'Velocity': <TalonFXControlMode.Velocity: 2>, 'Current': <TalonFXControlMode.Current: 3>, 'Follower': <TalonFXControlMode.Follower: 5>, 'MotionProfile': <TalonFXControlMode.MotionProfile: 6>, 'MotionMagic': <TalonFXControlMode.MotionMagic: 7>, 'MotionProfileArc': <TalonFXControlMode.MotionProfileArc: 10>, 'MusicTone': <TalonFXControlMode.MusicTone: 13>, 'Disabled': <TalonFXControlMode.Disabled: 15>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class TalonFXFeedbackDevice:
    """
    Choose the feedback device for a Talon FX/Falcon 500.
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    
    Members:
    
      IntegratedSensor : TalonFX supports an integrated sensor.
    
      SensorSum : Sum0 + Sum1
    
      SensorDifference : Diff0 - Diff1
    
      RemoteSensor0 : Sensor configured in RemoteFilter0
    
      RemoteSensor1 : Sensor configured in RemoteFilter1
    
      None_ : Position and velocity will read 0.
    
      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.
    """
    IntegratedSensor: typing.ClassVar[TalonFXFeedbackDevice]  # value = <TalonFXFeedbackDevice.IntegratedSensor: 1>
    None_: typing.ClassVar[TalonFXFeedbackDevice]  # value = <TalonFXFeedbackDevice.None_: 14>
    RemoteSensor0: typing.ClassVar[TalonFXFeedbackDevice]  # value = <TalonFXFeedbackDevice.RemoteSensor0: 11>
    RemoteSensor1: typing.ClassVar[TalonFXFeedbackDevice]  # value = <TalonFXFeedbackDevice.RemoteSensor1: 12>
    SensorDifference: typing.ClassVar[TalonFXFeedbackDevice]  # value = <TalonFXFeedbackDevice.SensorDifference: 10>
    SensorSum: typing.ClassVar[TalonFXFeedbackDevice]  # value = <TalonFXFeedbackDevice.SensorSum: 9>
    SoftwareEmulatedSensor: typing.ClassVar[TalonFXFeedbackDevice]  # value = <TalonFXFeedbackDevice.SoftwareEmulatedSensor: 15>
    __members__: typing.ClassVar[dict[str, TalonFXFeedbackDevice]]  # value = {'IntegratedSensor': <TalonFXFeedbackDevice.IntegratedSensor: 1>, 'SensorSum': <TalonFXFeedbackDevice.SensorSum: 9>, 'SensorDifference': <TalonFXFeedbackDevice.SensorDifference: 10>, 'RemoteSensor0': <TalonFXFeedbackDevice.RemoteSensor0: 11>, 'RemoteSensor1': <TalonFXFeedbackDevice.RemoteSensor1: 12>, 'None_': <TalonFXFeedbackDevice.None_: 14>, 'SoftwareEmulatedSensor': <TalonFXFeedbackDevice.SoftwareEmulatedSensor: 15>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class TalonFXInvertType:
    """
    Choose the invert type for a Talon FX based integrated motor controller.
    CCW is the equivalent of SetInverted(false), CW is the equivalent of SetInverted(true).
    FollowMaster/OpposeMaster will match/oppose a master Talon/Victor.  This requires device to be configured as a follower.
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    
    Members:
    
      CounterClockwise : Same as SetInverted(false)
    
      Clockwise : Same as SetInverted(true)
    
      FollowMaster : Follow the invert of the master this MC is following.
    
      OpposeMaster : Opposite of the invert of the master this MC is following.
    """
    Clockwise: typing.ClassVar[TalonFXInvertType]  # value = <TalonFXInvertType.Clockwise: 1>
    CounterClockwise: typing.ClassVar[TalonFXInvertType]  # value = <TalonFXInvertType.CounterClockwise: 0>
    FollowMaster: typing.ClassVar[TalonFXInvertType]  # value = <TalonFXInvertType.FollowMaster: 2>
    OpposeMaster: typing.ClassVar[TalonFXInvertType]  # value = <TalonFXInvertType.OpposeMaster: 3>
    __members__: typing.ClassVar[dict[str, TalonFXInvertType]]  # value = {'CounterClockwise': <TalonFXInvertType.CounterClockwise: 0>, 'Clockwise': <TalonFXInvertType.Clockwise: 1>, 'FollowMaster': <TalonFXInvertType.FollowMaster: 2>, 'OpposeMaster': <TalonFXInvertType.OpposeMaster: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class TalonFXPIDSetConfiguration(BaseTalonPIDSetConfiguration):
    """
    Configurables available to TalonFX's PID
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None:
        ...
class TalonFXSensorCollection:
    """
    Collection of sensors available to the Talon FX.
    
    For best performance and update-rate,
    we recommend using the configSelectedFeedbackSensor() and getSelectedSensor*() routines.
    However there are occasions where accessing raw sensor values may be useful or convenient.
    Particularly if you are seeding one sensor based on another, or need to circumvent sensor-phase.
    
    Use the GetTalonFXSensorCollection() routine inside your motor controller to create a sensor collection.
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    """
    def __init__(self, motorController: BaseTalon) -> None:
        """
        Constructor for TalonFXSensorCollection
        
        :param motorController: Talon Motor Controller to connect Collection to
        """
    def getIntegratedSensorAbsolutePosition(self) -> float:
        """
        Get the IntegratedSensor absolute position of the Talon FX, regardless of whether
        it is actually being used for feedback.  This will be within one rotation (2048 units).
        The signage and range will depend on the configuration.
        *	Note : Future versions of software may support scaling features (rotations, radians, degrees, etc) depending on the configuration.
        
        This method relies on the Status 21 message, which has a default period of 240ms. For more
        information, see: https://phoenix-documentation.readthedocs.io/en/latest/ch18_CommonAPI.html
        
        :returns: the IntegratedSensor absolute position.
        """
    def getIntegratedSensorPosition(self) -> float:
        ...
    def getIntegratedSensorVelocity(self) -> float:
        """
        Get the IntegratedSensor velocity of the Talon FX, regardless of whether
        it is actually being used for feedback.
        One unit represents one position unit per 100ms (2048 position units per 100ms).
        The signage and range will depend on the configuration.
        *	Note : Future versions of software may support scaling features (rotations, radians, degrees, etc) depending on the configuration.
        
        This method relies on the Status 21 message, which has a default period of 240ms. For more
        information, see: https://phoenix-documentation.readthedocs.io/en/latest/ch18_CommonAPI.html
        
        :returns: the IntegratedSensor velocity.
        """
    def isFwdLimitSwitchClosed(self) -> int:
        ...
    def isRevLimitSwitchClosed(self) -> int:
        ...
    def setIntegratedSensorPosition(self, newPosition: float, timeoutMs: int = 0) -> ErrorCode:
        """
        Set the IntegratedSensor reported position.  Typically this is used to "zero" the
        sensor. This only works with IntegratedSensor.  To set the selected sensor position
        regardless of what type it is, see SetSelectedSensorPosition in the motor controller class.
        
        :param newPosition: The position value to apply to the sensor.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.
        
        :returns: error code.
        """
    def setIntegratedSensorPositionToAbsolute(self, timeoutMs: int = 0) -> ErrorCode:
        """
        Set the IntegratedSensor reported position based on the absolute position.
        This can also be done automatically on power boot depending on configuration.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: error code.
        """
class TalonFXSimCollection:
    """
    Collection of simulation commands available to a TalonFX motor controller.
    
    Use the getSimCollection() routine inside your motor controller to create the respective sim collection.
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    """
    def __init__(self, motorController: BaseTalon) -> None:
        """
        Constructor for TalonFXSimCollection
        
        :param motorController: TalonFX Motor Controller to connect Collection to
        """
    def addIntegratedSensorPosition(self, dPos: int) -> ErrorCode:
        """
        Adds to the simulated integrated sensor position of the TalonFX.
        
        :param dPos: the change in position in native units
        
        :returns: error code
        """
    def getLastError(self) -> ErrorCode:
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.
        
        :returns: Last Error Code generated by a function.
        """
    def getMotorOutputLeadVoltage(self) -> float:
        """
        Gets the simulated output voltage across M+ and M- for the motor.
        
        :returns: applied voltage to the motor in volts
        """
    def setBusVoltage(self, vbat: float) -> ErrorCode:
        """
        Sets the simulated bus voltage of the TalonFX.
        
        The minimum allowed bus voltage is 4 V - values
        below this will be promoted to 4 V.
        
        :param vbat: the bus voltage in volts
        
        :returns: error code
        """
    def setIntegratedSensorRawPosition(self, newPos: int) -> ErrorCode:
        """
        Sets the simulated raw integrated sensor position of the TalonFX.
        
        The TalonFX integrates this to calculate the true reported integrated sensor
        position.
        
        When using the WPI Sim GUI, you will notice a readonly 'position' and
        settable 'rawPositionInput'.  The readonly signal is the emulated position
        which will match self-test in Tuner and the hardware API.  Changes to
        'rawPositionInput' will be integrated into the emulated position.  This way
        a simulator can modify the position without overriding your
        hardware API calls for home-ing your sensor.
        
        Inputs to this function over time should be continuous,
        as user calls of SetSelectedSensorPosition() and SetIntegratedSensorPosition()
        will be accounted for in the calculation.
        
        :param newPos: the new raw position in native units
        
        :returns: error code
        """
    def setIntegratedSensorVelocity(self, newVel: int) -> ErrorCode:
        """
        Sets the simulated integrated sensor velocity of the TalonFX.
        
        :param newVel: the new velocity in native units per 100ms
        
        :returns: error code
        """
    def setLimitFwd(self, isClosed: bool) -> ErrorCode:
        """
        Sets the simulated forward limit switch of the TalonFX.
        
        :param isClosed: true if the limit switch is closed
        
        :returns: error code
        """
    def setLimitRev(self, isClosed: bool) -> ErrorCode:
        """
        Sets the simulated reverse limit switch of the TalonFX.
        
        :param isClosed: true if the limit switch is closed
        
        :returns: error code
        """
    def setStatorCurrent(self, currA: float) -> ErrorCode:
        """
        Sets the simulated stator current of the TalonFX.
        
        :param currA: the stator current in amps
        
        :returns: error code
        """
    def setSupplyCurrent(self, currA: float) -> ErrorCode:
        """
        Sets the simulated supply current of the TalonFX.
        
        :param currA: the supply current in amps
        
        :returns: error code
        """
class TalonSRX(BaseTalon):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    
    ::
    
      {@code
      // Example usage of a TalonSRX motor controller
      TalonSRX motor{0}; // creates a new TalonSRX with ID 0
      
      TalonSRXConfiguration config;
      config.peakCurrentLimit = 40; // the peak current, in amps
      config.peakCurrentDuration = 1500; // the time at the peak current before the limit triggers, in ms
      config.continuousCurrentLimit = 30; // the current to maintain if the peak limit is triggered
      motor.ConfigAllSettings(config); // apply the config settings; this selects the quadrature encoder
      
      motor.Set(TalonSRXControlMode::PercentOutput, 0.5); // runs the motor at 50% power
      
      std::cout << motor.GetSelectedSensorPosition() << std::endl; // prints the position of the selected sensor
      std::cout << motor.GetSelectedSensorVelocity() << std::endl; // prints the velocity recorded by the selected sensor
      std::cout << motor.GetMotorOutputPercent() << std::endl; // prints the percent output of the motor (0.5)
      std::cout << motor.GetStatorCurrent() << std::endl; // prints the output current of the motor
      
      ErrorCode error = motor.GetLastError(); // gets the last error generated by the motor controller
      Faults faults;
      ErrorCode faultsError = motor.GetFaults(faults); // fills faults with the current motor controller faults; returns the last error generated
      
      motor.SetStatusFramePeriod(StatusFrameEnhanced::Status_2_Feedback0, 10); // changes the period of the Status 2 frame (GetSelectedSensor*()) to 10ms
      }
    
    .. seealso::
       :class:`WPI_TalonSRX`
    """
    @typing.overload
    def __init__(self, deviceNumber: int) -> None:
        """
        Constructor for a Talon
        
        :param deviceNumber: CAN Device ID of TalonSRX
        """
    @typing.overload
    def __init__(self, deviceNumber: int, canbus: str) -> None:
        """
        Constructor so non-FRC platforms can specify a CAN 2.0 socketcan bus
        
        :param deviceNumber: CAN Device ID of TalonSRX
        :param canbus:       String specifying the bus
        """
    def configAllSettings(self, allConfigs: TalonSRXConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures all persistent settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configContinuousCurrentLimit(self, amps: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configure the continuous allowable current-draw (when current limit is
        enabled).
        
        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.
        
        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        
        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).
        
        :param amps:      Amperes to limit.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        """
    def configPeakCurrentDuration(self, milliseconds: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configure the peak allowable duration (when current limit is enabled).
        
        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.
        
        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        
        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).
        
        :param milliseconds: How long to allow current-draw past peak limit.
        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for config
                             success and report an error if it times out. If zero, no
                             blocking or checking is performed.
        """
    def configPeakCurrentLimit(self, amps: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Configure the peak allowable current (when current limit is enabled).
        
        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.
        
        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        
        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).
        
        :param amps:      Amperes to limit.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                          success and report an error if it times out. If zero, no
                          blocking or checking is performed.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: TalonSRXFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the feedback device for the motor controller.
        
        :param feedbackDevice: Talon SRX Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int, timeoutMs: int = 0) -> ErrorCode:
        """
        Select the feedback device for the motor controller.
        
        :param feedbackDevice: Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int, timeoutMs: int) -> ErrorCode:
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.
        
        :param feedbackDevice: Remote Feedback Device to select.
        :param pidIdx:         0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures the supply (input) current limit.
        
        :param currLimitConfigs: Current limit configuration
        :param timeoutMs:        Timeout value in ms. If nonzero, function will wait for
                                 config success and report an error if it times out.
                                 If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configurePID(self, pid: TalonSRXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode:
        """
        Sets all PID persistant settings.
        
        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def enableCurrentLimit(self, enable: bool) -> None:
        """
        Enable or disable Current Limit.
        
        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.
        
        :param enable: Enable state of current limit.
                       @see configPeakCurrentLimit()
                       @see configPeakCurrentDuration()
                       @see configContinuousCurrentLimit()
        """
    def getAllConfigs(self, allConfigs: TalonSRXConfiguration, timeoutMs: int = 50) -> None:
        """
        Gets all persistant settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: TalonSRXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None:
        """
        Gets all PID set persistant settings.
        
        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getSensorCollection(self) -> SensorCollection:
        """
        :returns: object that can get/set individual RAW sensor values.
        """
    def getSimCollection(self) -> TalonSRXSimCollection:
        """
        :returns: object that can set simulation inputs.
        """
    @typing.overload
    def set(self, mode: TalonSRXControlMode, value: float) -> None:
        """
        Sets the appropriate output on the talon, depending on the mode.
        
        *	Standard Driving Example:
        *	_talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *	_talonRght.set(ControlMode.PercentOutput, rghtJoy);
        
        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Current mode, output value is in amperes.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the talon to
                      duplicate.
        :param value: The setpoint value, as described above.
        """
    @typing.overload
    def set(self, mode: TalonSRXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        """
        Arcade Drive Example:
        *		_talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);
        
        *	Drive Straight Example:
        *	Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);
        
        *	Drive Straight to a Distance Example:
        *	Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        
        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                            PID is always executed as standard Position PID control.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *	 demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.
                            AuxPID: Target position in Sensor Units
                            ArbitraryFeedForward: Percent Output between -1.0 and 1.0
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
class TalonSRXConfigUtil:
    """
    Util class to help with talon configs
    """
    @staticmethod
    def continuousCurrentLimitDifferent(settings: TalonSRXConfiguration) -> bool:
        ...
    @staticmethod
    def peakCurrentDurationDifferent(settings: TalonSRXConfiguration) -> bool:
        ...
    @staticmethod
    def peakCurrentLimitDifferent(settings: TalonSRXConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    def __init__(self) -> None:
        ...
class TalonSRXConfiguration(BaseTalonConfiguration):
    """
    Configurables available to TalonSRX
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to all the configs
        
        :returns: String representation of all the configs
        """
    @property
    def continuousCurrentLimit(self) -> int:
        """
        Continuous current in amps
        
        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    @continuousCurrentLimit.setter
    def continuousCurrentLimit(self, arg0: int) -> None:
        ...
    @property
    def peakCurrentDuration(self) -> int:
        """
        Peak Current duration in milliseconds
        
        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    @peakCurrentDuration.setter
    def peakCurrentDuration(self, arg0: int) -> None:
        ...
    @property
    def peakCurrentLimit(self) -> int:
        """
        Peak current in amps
        
        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    @peakCurrentLimit.setter
    def peakCurrentLimit(self, arg0: int) -> None:
        ...
class TalonSRXControlMode:
    """
    Choose the control mode for a Talon SRX.
    
    Members:
    
      PercentOutput : Percent output [-1,1]
    
      Position : Position closed loop
    
      Velocity : Velocity closed loop
    
      Current : Input current closed loop
    
      Follower : Follow other motor controller
    
      MotionProfile : Motion Profile
    
      MotionMagic : Motion Magic
    
      MotionProfileArc : Motion Profile with auxiliary output
    
      Disabled : Disable Motor Controller
    """
    Current: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.Current: 3>
    Disabled: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.Disabled: 15>
    Follower: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.Follower: 5>
    MotionMagic: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.MotionMagic: 7>
    MotionProfile: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.MotionProfile: 6>
    MotionProfileArc: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.MotionProfileArc: 10>
    PercentOutput: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.PercentOutput: 0>
    Position: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.Position: 1>
    Velocity: typing.ClassVar[TalonSRXControlMode]  # value = <TalonSRXControlMode.Velocity: 2>
    __members__: typing.ClassVar[dict[str, TalonSRXControlMode]]  # value = {'PercentOutput': <TalonSRXControlMode.PercentOutput: 0>, 'Position': <TalonSRXControlMode.Position: 1>, 'Velocity': <TalonSRXControlMode.Velocity: 2>, 'Current': <TalonSRXControlMode.Current: 3>, 'Follower': <TalonSRXControlMode.Follower: 5>, 'MotionProfile': <TalonSRXControlMode.MotionProfile: 6>, 'MotionMagic': <TalonSRXControlMode.MotionMagic: 7>, 'MotionProfileArc': <TalonSRXControlMode.MotionProfileArc: 10>, 'Disabled': <TalonSRXControlMode.Disabled: 15>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class TalonSRXFeedbackDevice:
    """
    Choose the feedback device for a Talon SRX
    
    Members:
    
      QuadEncoder : Quadrature encoder
    
      Analog : Analog potentiometer/encoder
    
      Tachometer : Tachometer
    
      PulseWidthEncodedPosition : CTRE Mag Encoder in Absolute mode or
    any other device that uses PWM to encode its output
    
      SensorSum : Sum0 + Sum1
    
      SensorDifference : Diff0 - Diff1
    
      RemoteSensor0 : Sensor configured in RemoteFilter0
    
      RemoteSensor1 : Sensor configured in RemoteFilter1
    
      None_ : Position and velocity will read 0.
    
      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.
    
      CTRE_MagEncoder_Absolute : CTR mag encoder configured in absolute, is the same
    as a PWM sensor.
    
      CTRE_MagEncoder_Relative : CTR mag encoder configured in relative, is the same
    as an quadrature encoder sensor.
    """
    Analog: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.Analog: 2>
    CTRE_MagEncoder_Absolute: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.PulseWidthEncodedPosition: 8>
    CTRE_MagEncoder_Relative: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.QuadEncoder: 0>
    None_: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.None_: 14>
    PulseWidthEncodedPosition: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.PulseWidthEncodedPosition: 8>
    QuadEncoder: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.QuadEncoder: 0>
    RemoteSensor0: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.RemoteSensor0: 11>
    RemoteSensor1: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.RemoteSensor1: 12>
    SensorDifference: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.SensorDifference: 10>
    SensorSum: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.SensorSum: 9>
    SoftwareEmulatedSensor: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.SoftwareEmulatedSensor: 15>
    Tachometer: typing.ClassVar[TalonSRXFeedbackDevice]  # value = <TalonSRXFeedbackDevice.Tachometer: 4>
    __members__: typing.ClassVar[dict[str, TalonSRXFeedbackDevice]]  # value = {'QuadEncoder': <TalonSRXFeedbackDevice.QuadEncoder: 0>, 'Analog': <TalonSRXFeedbackDevice.Analog: 2>, 'Tachometer': <TalonSRXFeedbackDevice.Tachometer: 4>, 'PulseWidthEncodedPosition': <TalonSRXFeedbackDevice.PulseWidthEncodedPosition: 8>, 'SensorSum': <TalonSRXFeedbackDevice.SensorSum: 9>, 'SensorDifference': <TalonSRXFeedbackDevice.SensorDifference: 10>, 'RemoteSensor0': <TalonSRXFeedbackDevice.RemoteSensor0: 11>, 'RemoteSensor1': <TalonSRXFeedbackDevice.RemoteSensor1: 12>, 'None_': <TalonSRXFeedbackDevice.None_: 14>, 'SoftwareEmulatedSensor': <TalonSRXFeedbackDevice.SoftwareEmulatedSensor: 15>, 'CTRE_MagEncoder_Absolute': <TalonSRXFeedbackDevice.PulseWidthEncodedPosition: 8>, 'CTRE_MagEncoder_Relative': <TalonSRXFeedbackDevice.QuadEncoder: 0>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class TalonSRXPIDSetConfiguration(BaseTalonPIDSetConfiguration):
    """
    Configurables available to TalonSRX's PID
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None:
        ...
class TalonSRXSimCollection:
    """
    Collection of simulation commands available to a TalonSRX motor controller.
    
    Use the getSimCollection() routine inside your motor controller to create the respective sim collection.
    """
    def addAnalogPosition(self, dPos: int) -> ErrorCode:
        """
        Adds to the simulated analog position of the TalonSRX.
        
        :param dPos: the change in position in native units
        
        :returns: error code
        """
    def addPulseWidthPosition(self, dPos: int) -> ErrorCode:
        """
        Adds to the simulated pulse width position of the TalonSRX.
        
        :param dPos: the change in position in native units
        
        :returns: error code
        """
    def addQuadraturePosition(self, dPos: int) -> ErrorCode:
        """
        Adds to the simulated quadrature position of the TalonSRX.
        
        :param dPos: the change in position in native units
        
        :returns: error code
        """
    def getLastError(self) -> ErrorCode:
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.
        
        :returns: Last Error Code generated by a function.
        """
    def getMotorOutputLeadVoltage(self) -> float:
        """
        Gets the simulated output voltage across M+ and M- for the motor.
        
        :returns: applied voltage to the motor in volts
        """
    def setAnalogPosition(self, newPos: int) -> ErrorCode:
        """
        Sets the simulated analog position of the TalonSRX.
        
        :param newPos: the new position in native units
        
        :returns: error code
        """
    def setAnalogVelocity(self, newVel: int) -> ErrorCode:
        """
        Sets the simulated analog velocity of the TalonSRX.
        
        :param newVel: the new velocity in native units per 100ms
        
        :returns: error code
        """
    def setBusVoltage(self, vbat: float) -> ErrorCode:
        """
        Sets the simulated bus voltage of the TalonSRX.
        
        The minimum allowed bus voltage is 4 V - values
        below this will be promoted to 4 V.
        
        :param vbat: the bus voltage in volts
        
        :returns: error code
        """
    def setLimitFwd(self, isClosed: bool) -> ErrorCode:
        """
        Sets the simulated forward limit switch of the TalonSRX.
        
        :param isClosed: true if the limit switch is closed
        
        :returns: error code
        """
    def setLimitRev(self, isClosed: bool) -> ErrorCode:
        """
        Sets the simulated reverse limit switch of the TalonSRX.
        
        :param isClosed: true if the limit switch is closed
        
        :returns: error code
        """
    def setPulseWidthConnected(self, isConnected: bool) -> ErrorCode:
        """
        Sets if the simulated pulse width sensor is connected to the TalonSRX.
        
        :param isConnected: true if the pulse width sensor is connected
        
        :returns: error code
        """
    def setPulseWidthPosition(self, newPos: int) -> ErrorCode:
        """
        Sets the simulated pulse width position of the TalonSRX.
        
        :param newPos: the new position in native units
        
        :returns: error code
        """
    def setPulseWidthRiseToRiseUs(self, periodUs: float) -> ErrorCode:
        """
        Sets the simulated pulse width rise to rise time of the TalonSRX.
        
        :param periodUs: the pulse width rise to rise time in microseconds
        
        :returns: error code
        """
    def setPulseWidthVelocity(self, newVel: int) -> ErrorCode:
        """
        Sets the simulated pulse width velocity of the TalonSRX.
        
        :param newVel: the new velocity in native units per 100ms
        
        :returns: error code
        """
    def setQuadratureRawPosition(self, newPos: int) -> ErrorCode:
        """
        Sets the simulated raw quadrature position of the TalonSRX.
        
        The TalonSRX integrates this to calculate the true reported quadrature
        position.
        
        When using the WPI Sim GUI, you will notice a readonly 'position' and
        settable 'rawPositionInput'.  The readonly signal is the emulated position
        which will match self-test in Tuner and the hardware API.  Changes to
        'rawPositionInput' will be integrated into the emulated position.  This way
        a simulator can modify the position without overriding your
        hardware API calls for home-ing your sensor.
        
        Inputs to this function over time should be continuous,
        as user calls of SetSelectedSensorPosition() and SetQuadraturePosition()
        will be accounted for in the calculation.
        
        :param newPos: the new raw position in native units
        
        :returns: error code
        """
    def setQuadratureVelocity(self, newVel: int) -> ErrorCode:
        """
        Sets the simulated quadrature velocity of the TalonSRX.
        
        :param newVel: the new velocity in native units per 100ms
        
        :returns: error code
        """
    def setStatorCurrent(self, currA: float) -> ErrorCode:
        """
        Sets the simulated stator current of the TalonSRX.
        
        :param currA: the stator current in amps
        
        :returns: error code
        """
    def setSupplyCurrent(self, currA: float) -> ErrorCode:
        """
        Sets the simulated supply current of the TalonSRX.
        
        :param currA: the supply current in amps
        
        :returns: error code
        """
class TrajectoryPoint:
    """
    Motion Profile Trajectory Point
    This is simply a data transfer object.
    """
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, position: float, velocity: float, arbFeedFwd: float, auxiliaryPos: float, auxiliaryVel: float, auxiliaryArbFeedFwd: float, profileSlotSelect0: int, profileSlotSelect1: int, isLastPoint: bool, zeroPos: bool, timeDur: int, useAuxPID: bool) -> None:
        ...
    @property
    def arbFeedFwd(self) -> float:
        """
        Added to the output of PID[0], should be within [-1,+1] where 0.01 = 1%.
        """
    @arbFeedFwd.setter
    def arbFeedFwd(self, arg0: float) -> None:
        ...
    @property
    def auxiliaryArbFeedFwd(self) -> float:
        """
        Added to the output of PID[1], should be within [-1,+1] where 0.01 = 1%.
        """
    @auxiliaryArbFeedFwd.setter
    def auxiliaryArbFeedFwd(self, arg0: float) -> None:
        ...
    @property
    def auxiliaryPos(self) -> float:
        """
        The position for auxiliary PID[1] to target (in sensor units).
        """
    @auxiliaryPos.setter
    def auxiliaryPos(self, arg0: float) -> None:
        ...
    @property
    def auxiliaryVel(self) -> float:
        """
        The velocity for auxiliary PID[1] to target. (in sensor-units per 100ms).
        """
    @auxiliaryVel.setter
    def auxiliaryVel(self, arg0: float) -> None:
        ...
    @property
    def headingDeg(self) -> float:
        """
        Not used.  Use auxiliaryPos instead.  @see auxiliaryPos
        """
    @headingDeg.setter
    def headingDeg(self, arg0: float) -> None:
        ...
    @property
    def isLastPoint(self) -> bool:
        """
        Set to true to signal Talon that this is the final point, so do not
        attempt to pop another trajectory point from out of the Talon buffer.
        Instead continue processing this way point.  Typically the velocity
        member variable should be zero so that the motor doesn't spin indefinitely.
        """
    @isLastPoint.setter
    def isLastPoint(self, arg0: bool) -> None:
        ...
    @property
    def position(self) -> float:
        """
        The position to servo to (in sensor units).
        """
    @position.setter
    def position(self, arg0: float) -> None:
        ...
    @property
    def profileSlotSelect0(self) -> int:
        """
        Which slot to get PIDF gains.
        PID is used for position servo.
        F is used as the Kv constant for velocity feed-forward.
        Typically this is hard-coded
        to a particular slot, but you are free to gain schedule if need be.
        gain schedule if need be.
        Choose from [0,3].
        """
    @profileSlotSelect0.setter
    def profileSlotSelect0(self, arg0: int) -> None:
        ...
    @property
    def profileSlotSelect1(self) -> int:
        """
        Which slot to get PIDF gains for auxiliary PID.
        This only has impact during MotionProfileArc Control mode.
        Choose from [0,3].
        """
    @profileSlotSelect1.setter
    def profileSlotSelect1(self, arg0: int) -> None:
        ...
    @property
    def timeDur(self) -> int:
        """
        Duration (ms) to apply this trajectory pt.
        This time unit is ADDED to the existing base time set by
        ConfigMotionProfileTrajectoryPeriod().
        """
    @timeDur.setter
    def timeDur(self, arg0: int) -> None:
        ...
    @property
    def useAuxPID(self) -> bool:
        """
        If using MotionProfileArc, this flag must be true on all points.
        If using MotionProfile, this flag must be false on all points.
        """
    @useAuxPID.setter
    def useAuxPID(self, arg0: bool) -> None:
        ...
    @property
    def velocity(self) -> float:
        """
        The velocity to feed-forward (in sensor-units per 100ms).
        """
    @velocity.setter
    def velocity(self, arg0: float) -> None:
        ...
    @property
    def zeroPos(self) -> bool:
        """
        Set to true to signal Talon to zero the selected sensor.
        When generating MPs, one simple method is to make the first target position zero,
        and the final target position the target distance from the current position.
        Then when you fire the MP, the current position gets set to zero.
        If this is the intent, you can set zeroPos on the first trajectory point.
        
        Otherwise you can leave this false for all points, and offset the positions
        of all trajectory points so they are correct.
        
        If using multiple sensor sources (Arc modes) we recommend you manually set sensor positions
        before arming MP.
        """
    @zeroPos.setter
    def zeroPos(self, arg0: bool) -> None:
        ...
class Unmanaged:
    """
    Handles enabling when used in a non-FRC manner
    """
    @staticmethod
    def feedEnable(timeoutMs: int) -> None:
        """
        Feed the enable frame.
        This function does nothing on a roborio during FRC use.
        
        If running an application in simulation, creating a WPI\_*
        object automatically enables actuators.
        Otherwise, call this to enable actuators.
        
        :param timeoutMs: Timeout before disabling
        """
    @staticmethod
    def getEnableState() -> bool:
        """
        :returns: true if enabled
        """
    @staticmethod
    def getPhoenixVersion() -> int:
        """
        :returns: Phoenix version
        """
    @staticmethod
    def loadPhoenix() -> None:
        """
        Calling this function will load and start
        the Phoenix background tasks.
        
        This can be useful if you need the
        Enable/Disable functionality for CAN devices
        but aren't using any of the CAN device classes.
        
        This function does NOT need to be called if
        you are using any of the Phoenix CAN device classes.
        """
    @staticmethod
    def setPhoenixDiagnosticsStartTime(startTimeSeconds: int) -> None:
        """
        Sets the duration of the delay before starting
        the Phoenix diagnostics server.
        
        :param startTime: Magnitude of the delay (in seconds) before
                          starting the server.
                          A value of 0 will start the server immediately.
                          A negative value will signal the server
                          to shutdown or never start.
        """
class VelocityMeasPeriod:
    """
    Velocity Measurement Periods
    
    Members:
    
      Period_1Ms : 1ms measurement period
    
      Period_2Ms : 2ms measurement period
    
      Period_5Ms : 5ms measurement period
    
      Period_10Ms : 10ms measurement period
    
      Period_20Ms : 20ms measurement period
    
      Period_25Ms : 25ms measurement period
    
      Period_50Ms : 50ms measurement period
    
      Period_100Ms : 100ms measurement period
    """
    Period_100Ms: typing.ClassVar[VelocityMeasPeriod]  # value = <VelocityMeasPeriod.Period_100Ms: 100>
    Period_10Ms: typing.ClassVar[VelocityMeasPeriod]  # value = <VelocityMeasPeriod.Period_10Ms: 10>
    Period_1Ms: typing.ClassVar[VelocityMeasPeriod]  # value = <VelocityMeasPeriod.Period_1Ms: 1>
    Period_20Ms: typing.ClassVar[VelocityMeasPeriod]  # value = <VelocityMeasPeriod.Period_20Ms: 20>
    Period_25Ms: typing.ClassVar[VelocityMeasPeriod]  # value = <VelocityMeasPeriod.Period_25Ms: 25>
    Period_2Ms: typing.ClassVar[VelocityMeasPeriod]  # value = <VelocityMeasPeriod.Period_2Ms: 2>
    Period_50Ms: typing.ClassVar[VelocityMeasPeriod]  # value = <VelocityMeasPeriod.Period_50Ms: 50>
    Period_5Ms: typing.ClassVar[VelocityMeasPeriod]  # value = <VelocityMeasPeriod.Period_5Ms: 5>
    __members__: typing.ClassVar[dict[str, VelocityMeasPeriod]]  # value = {'Period_1Ms': <VelocityMeasPeriod.Period_1Ms: 1>, 'Period_2Ms': <VelocityMeasPeriod.Period_2Ms: 2>, 'Period_5Ms': <VelocityMeasPeriod.Period_5Ms: 5>, 'Period_10Ms': <VelocityMeasPeriod.Period_10Ms: 10>, 'Period_20Ms': <VelocityMeasPeriod.Period_20Ms: 20>, 'Period_25Ms': <VelocityMeasPeriod.Period_25Ms: 25>, 'Period_50Ms': <VelocityMeasPeriod.Period_50Ms: 50>, 'Period_100Ms': <VelocityMeasPeriod.Period_100Ms: 100>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class VictorConfigUtil:
    """
    Util class to help with VictorSPX configs
    """
    @staticmethod
    def diff0TermDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def diff1TermDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def forwardLimitSwitchDeviceIDDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def forwardLimitSwitchDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def forwardLimitSwitchNormalDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def forwardLimitSwitchSourceDifferent(settings: VictorSPXConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def reverseLimitSwitchDeviceIDDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def reverseLimitSwitchDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def reverseLimitSwitchNormalDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def reverseLimitSwitchSourceDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def sum0TermDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    @staticmethod
    def sum1TermDifferent(settings: VictorSPXConfiguration) -> bool:
        ...
    def __init__(self) -> None:
        ...
class VictorSPX(BaseMotorController, IMotorController):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.
    
    ::
    
      {@code
      // Example usage of a VictorSPX motor controller
      VictorSPX motor{0}; // creates a new VictorSPX with ID 0
      
      motor.Set(VictorSPXControlMode::PercentOutput, 0.5); // runs the motor at 50% power
      
      std::cout << motor.GetMotorOutputPercent() << std::endl; // prints the percent output of the motor (0.5)
      std::cout << motor.GetBusVoltage() << std::endl; // prints the bus voltage seen by the motor controller
      
      ErrorCode error = motor.GetLastError(); // gets the last error generated by the motor controller
      Faults faults;
      ErrorCode faultsError = motor.GetFaults(faults); // fills faults with the current motor controller faults; returns the last error generated
      }
    
    .. seealso::
       :class:`WPI_VictorSPX`
    """
    @typing.overload
    def __init__(self, deviceNumber: int) -> None:
        """
        Constructor
        
        :param deviceNumber: [0,62]
        """
    @typing.overload
    def __init__(self, deviceNumber: int, canbus: str) -> None:
        """
        Constructor so non-FRC platforms can specify a CAN 2.0 socketcan bus
        
        :param deviceNumber: CAN Device ID of VictorSPX
        :param canbus:       String specifying the bus
        """
    def configAllSettings(self, allConfigs: VictorSPXConfiguration, timeoutMs: int = 50) -> ErrorCode:
        """
        Configures all persistent settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getAllConfigs(self, allConfigs: VictorSPXConfiguration, timeoutMs: int = 50) -> None:
        """
        Gets all persistant settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: VictorSPXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None:
        """
        Gets all PID set persistant settings.
        
        :param pid:       Object with all of the PID set persistant settings
        :param pidIdx:    0 for Primary closed-loop. 1 for auxiliary closed-loop.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        """
    def getSimCollection(self) -> VictorSPXSimCollection:
        """
        :returns: object that can set simulation inputs.
        """
    @typing.overload
    def set(self, mode: VictorSPXControlMode, value: float) -> None:
        """
        Sets the appropriate output on the motor controller, depending on the mode.
        
        *	Standard Driving Example:
        *	victorLeft.set(ControlMode.PercentOutput, leftJoy);
        *	victorRght.set(ControlMode.PercentOutput, rghtJoy);
        
        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the motor controller to
                      duplicate.
        :param value: The setpoint value, as described above.
        """
    @typing.overload
    def set(self, mode: VictorSPXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        """
        Arcade Drive Example:
        *		_victorLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *		_victorRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);
        
        *	Drive Straight Example:
        *	Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *		_victorLeft.follow(_victorRght, FollwerType.AuxOutput1);
        *		_victorRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);
        
        *	Drive Straight to a Distance Example:
        *	Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *		_victorLeft.follow(_victorRght, FollwerType.AuxOutput1);
        *		_victorRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        
        :param mode:        Sets the appropriate output on the motor controller, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the motor controller to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                            PID is always executed as standard Position PID control.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *	 demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.
                            AuxPID: Target position in Sensor Units
                            ArbitraryFeedForward: Percent Output between -1.0 and 1.0
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
class VictorSPXConfiguration(BaseMotorControllerConfiguration):
    """
    Configurables available to VictorSPX
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to all the configs
        
        :returns: String representation of all the configs
        """
    @property
    def auxiliaryPID(self) -> VictorSPXPIDSetConfiguration:
        """
        Auxiliary PID configuration
        """
    @auxiliaryPID.setter
    def auxiliaryPID(self, arg0: VictorSPXPIDSetConfiguration) -> None:
        ...
    @property
    def diff0Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Diff 0 Term
        """
    @diff0Term.setter
    def diff0Term(self, arg0: RemoteFeedbackDevice) -> None:
        ...
    @property
    def diff1Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Diff 1 Term
        """
    @diff1Term.setter
    def diff1Term(self, arg0: RemoteFeedbackDevice) -> None:
        ...
    @property
    def forwardLimitSwitchDeviceID(self) -> int:
        """
        Forward limit switch device ID
        
        Limit Switch device id isn't used unless device is a remote
        """
    @forwardLimitSwitchDeviceID.setter
    def forwardLimitSwitchDeviceID(self, arg0: int) -> None:
        ...
    @property
    def forwardLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Forward limit switch normally open/closed
        """
    @forwardLimitSwitchNormal.setter
    def forwardLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        ...
    @property
    def forwardLimitSwitchSource(self) -> RemoteLimitSwitchSource:
        """
        Forward Limit Switch Source
        
        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @forwardLimitSwitchSource.setter
    def forwardLimitSwitchSource(self, arg0: RemoteLimitSwitchSource) -> None:
        ...
    @property
    def primaryPID(self) -> VictorSPXPIDSetConfiguration:
        """
        Primary PID configuration
        """
    @primaryPID.setter
    def primaryPID(self, arg0: VictorSPXPIDSetConfiguration) -> None:
        ...
    @property
    def reverseLimitSwitchDeviceID(self) -> int:
        """
        Reverse limit switch device ID
        
        Limit Switch device id isn't used unless device is a remote
        """
    @reverseLimitSwitchDeviceID.setter
    def reverseLimitSwitchDeviceID(self, arg0: int) -> None:
        ...
    @property
    def reverseLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Reverse limit switch normally open/closed
        """
    @reverseLimitSwitchNormal.setter
    def reverseLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        ...
    @property
    def reverseLimitSwitchSource(self) -> RemoteLimitSwitchSource:
        """
        Reverse Limit Switch Source
        
        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @reverseLimitSwitchSource.setter
    def reverseLimitSwitchSource(self, arg0: RemoteLimitSwitchSource) -> None:
        ...
    @property
    def sum0Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Sum 0 Term
        """
    @sum0Term.setter
    def sum0Term(self, arg0: RemoteFeedbackDevice) -> None:
        ...
    @property
    def sum1Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Sum 1 Term
        """
    @sum1Term.setter
    def sum1Term(self, arg0: RemoteFeedbackDevice) -> None:
        ...
class VictorSPXControlMode:
    """
    Choose the control mode for a Victor SPX.
    
    Members:
    
      PercentOutput : Percent output [-1,1]
    
      Position : Position closed loop
    
      Velocity : Velocity closed loop
    
      Follower : Follow other motor controller
    
      MotionProfile : Motion Profile
    
      MotionMagic : Motion Magic
    
      MotionProfileArc : Motion Profile with auxiliary output
    
      Disabled : Disable Motor Controller
    """
    Disabled: typing.ClassVar[VictorSPXControlMode]  # value = <VictorSPXControlMode.Disabled: 15>
    Follower: typing.ClassVar[VictorSPXControlMode]  # value = <VictorSPXControlMode.Follower: 5>
    MotionMagic: typing.ClassVar[VictorSPXControlMode]  # value = <VictorSPXControlMode.MotionMagic: 7>
    MotionProfile: typing.ClassVar[VictorSPXControlMode]  # value = <VictorSPXControlMode.MotionProfile: 6>
    MotionProfileArc: typing.ClassVar[VictorSPXControlMode]  # value = <VictorSPXControlMode.MotionProfileArc: 10>
    PercentOutput: typing.ClassVar[VictorSPXControlMode]  # value = <VictorSPXControlMode.PercentOutput: 0>
    Position: typing.ClassVar[VictorSPXControlMode]  # value = <VictorSPXControlMode.Position: 1>
    Velocity: typing.ClassVar[VictorSPXControlMode]  # value = <VictorSPXControlMode.Velocity: 2>
    __members__: typing.ClassVar[dict[str, VictorSPXControlMode]]  # value = {'PercentOutput': <VictorSPXControlMode.PercentOutput: 0>, 'Position': <VictorSPXControlMode.Position: 1>, 'Velocity': <VictorSPXControlMode.Velocity: 2>, 'Follower': <VictorSPXControlMode.Follower: 5>, 'MotionProfile': <VictorSPXControlMode.MotionProfile: 6>, 'MotionMagic': <VictorSPXControlMode.MotionMagic: 7>, 'MotionProfileArc': <VictorSPXControlMode.MotionProfileArc: 10>, 'Disabled': <VictorSPXControlMode.Disabled: 15>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class VictorSPXPIDSetConfigUtil:
    """
    Util class to help with VictorSPX's PID configs
    """
    @staticmethod
    def selectedFeedbackCoefficientDifferent(settings: VictorSPXPIDSetConfiguration) -> bool:
        ...
    @staticmethod
    def selectedFeedbackSensorDifferent(settings: VictorSPXPIDSetConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    def __init__(self) -> None:
        ...
class VictorSPXPIDSetConfiguration(BasePIDSetConfiguration):
    """
    Configurables available to VictorSPX's PID
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of all the configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to all the configs
        
        :returns: String representation of all the configs
        """
    @property
    def selectedFeedbackSensor(self) -> RemoteFeedbackDevice:
        """
        Feedback device for a particular PID loop.
        """
    @selectedFeedbackSensor.setter
    def selectedFeedbackSensor(self, arg0: RemoteFeedbackDevice) -> None:
        ...
class VictorSPXSimCollection:
    """
    Collection of simulation commands available to a VictorSPX motor controller.
    
    Use the getSimCollection() routine inside your motor controller to create the respective sim collection.
    """
    def getLastError(self) -> ErrorCode:
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.
        
        :returns: Last Error Code generated by a function.
        """
    def getMotorOutputLeadVoltage(self) -> float:
        """
        Gets the simulated output voltage across M+ and M- for the motor.
        
        :returns: applied voltage to the motor in volts
        """
    def setBusVoltage(self, vbat: float) -> ErrorCode:
        """
        Sets the simulated bus voltage of the VictorSPX.
        
        The minimum allowed bus voltage is 4 V - values
        below this will be promoted to 4 V.
        
        :param vbat: the bus voltage in volts
        
        :returns: error code
        """
class WPI_BaseMotorController(BaseMotorController, wpilib.interfaces._interfaces.MotorController, wpilib._wpilib.MotorSafety, wpiutil._wpiutil.Sendable):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int, model: str) -> None:
        """
        Constructor for a WPI_BaseMotorController
        
        :param deviceNumber: Device ID of BaseMotorController
        """
    def disable(self) -> None:
        """
        Common interface for disabling a motor.
        """
    def get(self) -> float:
        """
        Common interface for getting the current set speed of a speed controller.
        
        :returns: The current set speed.  Value is between -1.0 and 1.0.
        """
    def getDescription(self) -> str:
        """
        :returns: description of controller
        """
    def getInverted(self) -> bool:
        """
        Common interface for returning the inversion state of a speed controller.
        
        :returns: isInverted The state of inversion, true is inverted.
        """
    @typing.overload
    def set(self, speed: float) -> None:
        """
        Common interface for setting the speed of a simple speed controller.
        
        :param speed: The speed to set.  Value should be between -1.0 and 1.0.
                      Value is also saved for Get().
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None:
        """
        Sets the appropriate output on the talon, depending on the mode.
        
        *	Standard Driving Example:
        *	_talonLeft.set(ControlMode.PercentOutput, leftJoy);
        *	_talonRght.set(ControlMode.PercentOutput, rghtJoy);
        
        :param mode:  The output mode to apply.
                      In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                      In Current mode, output value is in amperes.
                      In Velocity mode, output value is in position change / 100ms.
                      In Position mode, output value is in encoder ticks or an analog value,
                      depending on the sensor.
                      In Follower mode, the output value is the integer device ID of the talon to
                      duplicate.
        :param value: The setpoint value, as described above.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        """
        Arcade Drive Example:
        *		_talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);
        
        *	Drive Straight Example:
        *	Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);
        
        *	Drive Straight to a Distance Example:
        *	Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
        *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
        *		_talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        
        :param mode:        Sets the appropriate output on the talon, depending on the mode.
        :param demand0:     The output value to apply.
                            such as advanced feed forward and/or auxiliary close-looping in firmware.
                            In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                            In Current mode, output value is in amperes.
                            In Velocity mode, output value is in position change / 100ms.
                            In Position mode, output value is in encoder ticks or an analog value,
                            depending on the sensor. See
                            In Follower mode, the output value is the integer device ID of the talon to
                            duplicate.
        :param demand1Type: The demand type for demand1.
                            Neutral: Ignore demand1 and apply no change to the demand0 output.
                            AuxPID: Use demand1 to set the target for the auxiliary PID 1.
                            ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                            *	 demand0 output.  In PercentOutput the demand0 output is the motor output,
                            and in closed-loop modes the demand0 output is the output of PID0.
        :param demand1:     Supplmental output value.  Units match the set mode.
        """
    @typing.overload
    def setInverted(self, isInverted: bool) -> None:
        """
        Common interface for inverting direction of a speed controller.
        
        :param isInverted: The state of inversion, true is inverted.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None:
        """
        Common interface for inverting direction of a speed controller.
        
        :param invertType: The invert strategy to use. Follower controllers
                           that mirror/oppose the master controller should
                           *					use this method.
        """
    def setVoltage(self, output: wpimath.units.volts) -> None:
        """
        Sets the voltage output of the SpeedController.  Compensates for
        the current bus voltage to ensure that the desired voltage is output even
        if the battery voltage is below 12V - highly useful when the voltage
        outputs are "meaningful" (e.g. they come from a feedforward calculation).
        
        NOTE: This function *must* be called regularly in order for voltage
        compensation to work properly - unlike the ordinary set function, it is not
        "set it and forget it."
        
        :param output: The voltage to output.
        """
    def stopMotor(self) -> None:
        """
        Common interface to stop the motor until Set is called again.
        """
class WPI_TalonFX(TalonFX, WPI_BaseMotorController):
    """
    CTRE Talon FX Motor Controller when used on CAN Bus.
    
    If the Phoenix 5 API must be used for this device, the device must have 22.X
    firmware. This firmware is available in Tuner X after selecting Phoenix 5 in
    the firmware year dropdown.
    
    :deprecated: This device's Phoenix 5 API is deprecated for removal in the
                 2025 season. Users should update to Phoenix 6 firmware and migrate to the
                 Phoenix 6 API. A migration guide is available at
                 https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html.
    """
    def __init__(self, deviceNumber: int, canbus: str = '') -> None:
        """
        Constructor for a WPI_TalonFX
        
        :param deviceNumber: Device ID of TalonFX
        :param canbus:       Name of the CANbus; can be a CANivore device name or serial number.
                             Pass in nothing or "rio" to use the roboRIO.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        ...
    @typing.overload
    def set(self, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
    @typing.overload
    def setInverted(self, invertType: TalonFXInvertType) -> None:
        ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None:
        ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None:
        ...
    def setVoltage(self, output: wpimath.units.volts) -> None:
        ...
class WPI_TalonSRX(TalonSRX, WPI_BaseMotorController):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None:
        """
        Constructor for a WPI_TalonSRX
        
        :param deviceNumber: Device ID of TalonSRX
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        ...
    @typing.overload
    def set(self, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None:
        ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None:
        ...
    def setVoltage(self, output: wpimath.units.volts) -> None:
        ...
class WPI_VictorSPX(VictorSPX, WPI_BaseMotorController):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None:
        """
        Constructor for a WPI_VictorSPX
        
        :param deviceNumber: Device ID of VictorSPX
        """
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode:
        ...
    @typing.overload
    def set(self, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, value: float) -> None:
        ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None:
        ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None:
        ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None:
        ...
    def setVoltage(self, output: wpimath.units.volts) -> None:
        ...
